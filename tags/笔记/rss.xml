  
<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title>宝硕博客 • Posts by &#34;笔记&#34; tag</title>
        <link>https://blog.baoshuo.ren</link>
        <description>宝硕博客 —— Baoshuo (@renbaoshuo) 随便写东西的地方，以技术向博文为主，生活向博文为辅。</description>
        <language>cn</language>
        <pubDate>Thu, 12 Aug 2021 10:50:06 +0800</pubDate>
        <lastBuildDate>Thu, 12 Aug 2021 10:50:06 +0800</lastBuildDate>
        <category>BIRD</category>
        <category>BGP</category>
        <category>算法</category>
        <category>图论</category>
        <category>笔记</category>
        <category>Web</category>
        <category>CTF</category>
        <category>DN42</category>
        <category>Git</category>
        <category>折腾</category>
        <category>Linux</category>
        <category>网络</category>
        <category>题解</category>
        <category>洛谷</category>
        <category>游记</category>
        <category>牛客网</category>
        <category>S2OJ</category>
        <category>macOS</category>
        <category>Cloudflare</category>
        <category>前端</category>
        <category>比赛</category>
        <item>
            <guid isPermalink="true">https://blog.baoshuo.ren/post/graph-shortest-path/</guid>
            <title>最短路学习笔记</title>
            <link>https://blog.baoshuo.ren/post/graph-shortest-path/</link>
            <category>算法</category>
            <category>图论</category>
            <category>笔记</category>
            <pubDate>Thu, 12 Aug 2021 10:50:06 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;最短路径问题是图论研究中的一个经典算法问题，旨在寻找图（由节点和路径组成的）中两节点之间的最短路径。&lt;/p&gt;
&lt;a id=&#34;more&#34;&gt;&lt;/a&gt;
&lt;p&gt;由于竞赛中不考查文中所述算法的证明，故本文不探讨与证明相关的内容，如有需要请自行查阅维基百科。&lt;/p&gt;
&lt;h2 id=&#34;性质&#34;&gt;性质&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;对于边权为正的图，任意两个节点间的最短路不会重复经过某一个点或某一条边。&lt;/li&gt;
&lt;li&gt;对于边权为正的图，任意两个节点间的最短路中的任意一条的节点数不会超过 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;n&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;n&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; ，边数不会超过 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;n - 1&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.66666em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;确定起点的最短路径问题&#34;&gt;确定起点的最短路径问题&lt;/h2&gt;
&lt;p&gt;这种问题也叫单源最短路问题，即已知起始节点，求最短路径的问题。在边权非负时适合使用 Dijkstra 算法，若边权为负时则适合使用 Bellman-ford 算法或者 SPFA 算法。&lt;/p&gt;
&lt;h3 id=&#34;Dijkstra-算法&#34;&gt;Dijkstra 算法&lt;/h3&gt;
&lt;p&gt;该算法的时间复杂度为 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo stretchy=&#34;false&#34;&gt;(&lt;/mo&gt;&lt;msup&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msup&gt;&lt;mo stretchy=&#34;false&#34;&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;O(n^2)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.064108em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; ，使用&lt;a href=&#34;#%E5%A0%86%E4%BC%98%E5%8C%96%E7%9A%84-Dijkstra-%E7%AE%97%E6%B3%95&#34;&gt;堆优化&lt;/a&gt;后可达 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo stretchy=&#34;false&#34;&gt;(&lt;/mo&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;log&lt;/mi&gt;&lt;mo&gt;⁡&lt;/mo&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mo stretchy=&#34;false&#34;&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;O(m \log m)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mop&#34;&gt;lo&lt;span style=&#34;margin-right:0.01389em;&#34;&gt;g&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 。&lt;/p&gt;
&lt;h4 id=&#34;演示&#34;&gt;演示&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://vip2.loli.io/2021/07/19/Ppk3vdLbMyqKoEl.gif&#34; alt=&#34;Dijkstra 算法运行演示&#34; loading=&#34;lazy&#34; data-action=&#34;zoom&#34;&gt;&lt;span class=&#34;image-description&#34;&gt;Dijkstra 算法运行演示&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Dijkstra 算法每次取出未访问节点中距离最小的节点，并用该节点更新其他节点的距离。（在演示过程中访问过的节点会被标为红色）&lt;/p&gt;
&lt;h4 id=&#34;实现&#34;&gt;实现&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;定义一个名为 &lt;code&gt;dist&lt;/code&gt; 的数组存储从起点到各点的距离，并将起点的值初始化为 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;0&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 、其余点的距离初始化为 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;∞&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;\infty&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;∞&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 。&lt;br&gt;定义一个名为 &lt;code&gt;g&lt;/code&gt; 的二维数组存图，将各点自己到自己的距离值初始化为 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;0&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; ，其余距离值初始化为 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;∞&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;\infty&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;∞&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 。&lt;br&gt;设集合 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;S&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;S&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34; style=&#34;margin-right:0.05764em;&#34;&gt;S&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 存储当前已确定最短路的点。&lt;/li&gt;
&lt;li&gt;遍历 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;n - 1&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.66666em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 次，每次寻找一个不在 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;S&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;S&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34; style=&#34;margin-right:0.05764em;&#34;&gt;S&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 中的且距离起点最近的点，记为 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;t&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.61508em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;t&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; ，并将 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;t&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.61508em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;t&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 加入集合 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;S&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;S&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34; style=&#34;margin-right:0.05764em;&#34;&gt;S&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 。当从起点到某个点的距离比从起点经过 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;t&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.61508em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;t&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 再到这个点的距离大时就更新从起点到这个点的距离，即 &lt;code&gt;dist[j] = min(dist[j], dist[t] + g[t][j])&lt;/code&gt; 。&lt;/li&gt;
&lt;li&gt;最后 &lt;code&gt;dist&lt;/code&gt; 数组里即为从起点到各点的最短距离。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;代码&#34;&gt;代码&lt;/h4&gt;
&lt;p&gt;题目链接：&lt;a href=&#34;https://www.acwing.com/problem/content/description/851/&#34;&gt;849. Dijkstra 求最短路 I - AcWing&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;highlight cpp&#34;&gt;&lt;span class=&#34;meta&#34;&gt;#&lt;span class=&#34;meta-keyword&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;meta-string&#34;&gt;&amp;lt;bits/stdc++.h&amp;gt;&lt;/span&gt;&lt;/span&gt;

&lt;span class=&#34;keyword&#34;&gt;using&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;namespace&lt;/span&gt; std;

&lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; n, m, x, y, z, g[&lt;span class=&#34;number&#34;&gt;505&lt;/span&gt;][&lt;span class=&#34;number&#34;&gt;505&lt;/span&gt;], dist[&lt;span class=&#34;number&#34;&gt;505&lt;/span&gt;];
&lt;span class=&#34;keyword&#34;&gt;bool&lt;/span&gt; st[&lt;span class=&#34;number&#34;&gt;505&lt;/span&gt;];

&lt;span class=&#34;function&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;diskstra&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;
    &lt;span class=&#34;built_in&#34;&gt;memset&lt;/span&gt;(dist, &lt;span class=&#34;number&#34;&gt;0x3f&lt;/span&gt;, &lt;span class=&#34;built_in&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;sizeof&lt;/span&gt;&lt;/span&gt;(dist));
    dist[&lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;] = &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;;
    &lt;span class=&#34;keyword&#34;&gt;for&lt;/span&gt; (&lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; i = &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;; i &amp;lt; n; i++) &amp;#123;
        &lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; t = &lt;span class=&#34;number&#34;&gt;-1&lt;/span&gt;;
        &lt;span class=&#34;keyword&#34;&gt;for&lt;/span&gt; (&lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; j = &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;; j &amp;lt;= n; j++) &amp;#123;
            &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (!st[j] &amp;amp;&amp;amp; (t == &lt;span class=&#34;number&#34;&gt;-1&lt;/span&gt; || dist[t] &amp;gt; dist[j])) &amp;#123;
                t = j;
            &amp;#125;
        &amp;#125;
        &lt;span class=&#34;keyword&#34;&gt;for&lt;/span&gt; (&lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; j = &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;; j &amp;lt;= n; j++) &amp;#123;
            dist[j] = &lt;span class=&#34;built_in&#34;&gt;min&lt;/span&gt;(dist[j], dist[t] + g[t][j]);
        &amp;#125;
        st[t] = &lt;span class=&#34;literal&#34;&gt;true&lt;/span&gt;;
    &amp;#125;
    &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; dist[n] == &lt;span class=&#34;number&#34;&gt;0x3f3f3f3f&lt;/span&gt; ? &lt;span class=&#34;number&#34;&gt;-1&lt;/span&gt; : dist[n];
&amp;#125;

&lt;span class=&#34;function&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    &lt;span class=&#34;keyword&#34;&gt;for&lt;/span&gt; (&lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; i = &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;; i &amp;lt;= n; i++) &amp;#123;
        &lt;span class=&#34;keyword&#34;&gt;for&lt;/span&gt; (&lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; j = &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;; j &amp;lt;= n; j++) &amp;#123;
            g[i][j] = i == j ? &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt; : &lt;span class=&#34;number&#34;&gt;0x3f3f3f3f&lt;/span&gt;;
        &amp;#125;
    &amp;#125;
    &lt;span class=&#34;keyword&#34;&gt;for&lt;/span&gt; (&lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; i = &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;; i &amp;lt;= m; i++) &amp;#123;
        cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y &amp;gt;&amp;gt; z;
        g[x][y] = &lt;span class=&#34;built_in&#34;&gt;min&lt;/span&gt;(g[x][y], z);
    &amp;#125;
    cout &amp;lt;&amp;lt; &lt;span class=&#34;built_in&#34;&gt;diskstra&lt;/span&gt;() &amp;lt;&amp;lt; endl;
    &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;堆优化的-Dijkstra-算法&#34;&gt;堆优化的 Dijkstra 算法&lt;/h3&gt;
&lt;p&gt;使用堆优化的 Dijkstra 算法的时间复杂度为 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo stretchy=&#34;false&#34;&gt;(&lt;/mo&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;log&lt;/mi&gt;&lt;mo&gt;⁡&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo stretchy=&#34;false&#34;&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;O(m \log n)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mop&#34;&gt;lo&lt;span style=&#34;margin-right:0.01389em;&#34;&gt;g&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&#34;实现-2&#34;&gt;实现&lt;/h4&gt;
&lt;p&gt;使用堆代替找距离最近的点的操作即可。&lt;/p&gt;
&lt;p&gt;由于 C++ STL 中的优先队列不支持删除元素的操作，所以队列中会有重复元素导致复杂度变为 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo stretchy=&#34;false&#34;&gt;(&lt;/mo&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;log&lt;/mi&gt;&lt;mo&gt;⁡&lt;/mo&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mo stretchy=&#34;false&#34;&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;O(m \log m)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mop&#34;&gt;lo&lt;span style=&#34;margin-right:0.01389em;&#34;&gt;g&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; ，但比手写堆要容易许多。&lt;/p&gt;
&lt;h4 id=&#34;代码-2&#34;&gt;代码&lt;/h4&gt;
&lt;p&gt;题目链接：&lt;a href=&#34;https://www.acwing.com/problem/content/description/852/&#34;&gt;850. Dijkstra 求最短路 II&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;highlight cpp&#34;&gt;&lt;span class=&#34;meta&#34;&gt;#&lt;span class=&#34;meta-keyword&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;meta-string&#34;&gt;&amp;lt;bits/stdc++.h&amp;gt;&lt;/span&gt;&lt;/span&gt;

&lt;span class=&#34;keyword&#34;&gt;using&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;namespace&lt;/span&gt; std;

&lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; n, m, u, v, w, dist[&lt;span class=&#34;number&#34;&gt;200005&lt;/span&gt;];
vector&amp;lt;pair&amp;lt;&lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt;, &lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt;&amp;gt;&amp;gt; g[&lt;span class=&#34;number&#34;&gt;200005&lt;/span&gt;];
&lt;span class=&#34;keyword&#34;&gt;bool&lt;/span&gt; st[&lt;span class=&#34;number&#34;&gt;200005&lt;/span&gt;];

&lt;span class=&#34;function&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;dijkstra&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;
    &lt;span class=&#34;built_in&#34;&gt;memset&lt;/span&gt;(dist, &lt;span class=&#34;number&#34;&gt;0x3f&lt;/span&gt;, &lt;span class=&#34;built_in&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;sizeof&lt;/span&gt;&lt;/span&gt;(dist));
    dist[&lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;] = &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;;
    priority_queue&amp;lt;pair&amp;lt;&lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt;, &lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt;&amp;gt;, vector&amp;lt;pair&amp;lt;&lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt;, &lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt;&amp;gt;&amp;gt;, greater&amp;lt;pair&amp;lt;&lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt;, &lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; q;
    q.&lt;span class=&#34;built_in&#34;&gt;push&lt;/span&gt;(&lt;span class=&#34;built_in&#34;&gt;make_pair&lt;/span&gt;(&lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;, &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;));
    &lt;span class=&#34;keyword&#34;&gt;while&lt;/span&gt; (!q.&lt;span class=&#34;built_in&#34;&gt;empty&lt;/span&gt;()) &amp;#123;
        &lt;span class=&#34;keyword&#34;&gt;auto&lt;/span&gt; t = q.&lt;span class=&#34;built_in&#34;&gt;top&lt;/span&gt;();
        q.&lt;span class=&#34;built_in&#34;&gt;pop&lt;/span&gt;();
        &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (st[t.second]) &lt;span class=&#34;keyword&#34;&gt;continue&lt;/span&gt;;
        &lt;span class=&#34;keyword&#34;&gt;for&lt;/span&gt; (&lt;span class=&#34;keyword&#34;&gt;auto&lt;/span&gt; i : g[t.second]) &amp;#123;
            &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (dist[i.first] &amp;gt; t.first + i.second) &amp;#123;
                dist[i.first] = t.first + i.second;
                q.&lt;span class=&#34;built_in&#34;&gt;push&lt;/span&gt;(&lt;span class=&#34;built_in&#34;&gt;make_pair&lt;/span&gt;(dist[i.first], i.first));
            &amp;#125;
        &amp;#125;
        st[tw] = &lt;span class=&#34;literal&#34;&gt;true&lt;/span&gt;;
    &amp;#125;
&amp;#125;

&lt;span class=&#34;function&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    &lt;span class=&#34;keyword&#34;&gt;for&lt;/span&gt; (&lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; i = &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;; i &amp;lt;= m; i++) &amp;#123;
        cin &amp;gt;&amp;gt; u &amp;gt;&amp;gt; v &amp;gt;&amp;gt; w;
        g[u].&lt;span class=&#34;built_in&#34;&gt;push_back&lt;/span&gt;(&lt;span class=&#34;built_in&#34;&gt;make_pair&lt;/span&gt;(v, w));
    &amp;#125;
    &lt;span class=&#34;built_in&#34;&gt;dijkstra&lt;/span&gt;();
    cout &amp;lt;&amp;lt; (dist[n] == &lt;span class=&#34;number&#34;&gt;0x3f3f3f3f&lt;/span&gt; ? &lt;span class=&#34;number&#34;&gt;-1&lt;/span&gt; : dist[n]) &amp;lt;&amp;lt; endl;
    &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;Bellman-Ford-算法&#34;&gt;Bellman-Ford 算法&lt;/h3&gt;
&lt;p&gt;该算法的时间复杂度为 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo stretchy=&#34;false&#34;&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mo stretchy=&#34;false&#34;&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;O(nm)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; （对于存在最短路的图）。&lt;/p&gt;
&lt;h4 id=&#34;实现-3&#34;&gt;实现&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;定义一个名为 &lt;code&gt;dist&lt;/code&gt; 的数组存储从起点到各点的距离，并将起点的值初始化为 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;0&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 、其余点的距离初始化为 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;∞&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;\infty&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;∞&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 。&lt;/li&gt;
&lt;li&gt;遍历 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;n&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;n&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 次，并进行以下操作：
&lt;ol&gt;
&lt;li&gt;遍历所有边 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo stretchy=&#34;false&#34;&gt;(&lt;/mo&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;v&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;w&lt;/mi&gt;&lt;mo stretchy=&#34;false&#34;&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;(u, v, w)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34; style=&#34;margin-right:0.03588em;&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34; style=&#34;margin-right:0.02691em;&#34;&gt;w&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; ：若已有的从起点到 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;v&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;v&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34; style=&#34;margin-right:0.03588em;&#34;&gt;v&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 的路径长度大于从起点经过 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mo&gt;→&lt;/mo&gt;&lt;mi&gt;v&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;u \to v&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;→&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34; style=&#34;margin-right:0.03588em;&#34;&gt;v&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 这条边的路径长度，则更新最短路径长度。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dist&lt;/code&gt; 数组即为所求。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;判断负环&#34;&gt;判断负环&lt;/h4&gt;
&lt;p&gt;在第 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;n&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;n&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 次遍历后如果仍能更新最短路径长度则可以判断存在负环。&lt;/p&gt;
&lt;h4 id=&#34;代码-3&#34;&gt;代码&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;highlight cpp&#34;&gt;&lt;span class=&#34;meta&#34;&gt;#&lt;span class=&#34;meta-keyword&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;meta-string&#34;&gt;&amp;lt;bits/stdc++.h&amp;gt;&lt;/span&gt;&lt;/span&gt;

&lt;span class=&#34;keyword&#34;&gt;using&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;namespace&lt;/span&gt; std;

&lt;span class=&#34;class&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;node&lt;/span&gt; &amp;#123;&lt;/span&gt;
    &lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; u, v, w;
&amp;#125; g[&lt;span class=&#34;number&#34;&gt;10005&lt;/span&gt;];

&lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; n, m, k, dist[&lt;span class=&#34;number&#34;&gt;505&lt;/span&gt;];

&lt;span class=&#34;function&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;bellman_ford&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;
    &lt;span class=&#34;built_in&#34;&gt;memset&lt;/span&gt;(dist, &lt;span class=&#34;number&#34;&gt;0x3f&lt;/span&gt;, &lt;span class=&#34;built_in&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;sizeof&lt;/span&gt;&lt;/span&gt;(dist));
    dist[&lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;] = &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;;
    &lt;span class=&#34;keyword&#34;&gt;for&lt;/span&gt; (&lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; i = &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;; i &amp;lt;= k; i++) &amp;#123;
        &lt;span class=&#34;keyword&#34;&gt;for&lt;/span&gt; (&lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; j = &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;; j &amp;lt;= m; j++) &amp;#123;
            dist[g[j].v] = &lt;span class=&#34;built_in&#34;&gt;min&lt;/span&gt;(dist[g[j].v], dist[g[j].u] + g[j].w);
        &amp;#125;
    &amp;#125;
&amp;#125;

&lt;span class=&#34;function&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m &amp;gt;&amp;gt; k;
    &lt;span class=&#34;keyword&#34;&gt;for&lt;/span&gt; (&lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; i = &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;; i &amp;lt;= m; i++) &amp;#123;
        cin &amp;gt;&amp;gt; g[i].u &amp;gt;&amp;gt; g[i].v &amp;gt;&amp;gt; g[i].w;
    &amp;#125;
    &lt;span class=&#34;built_in&#34;&gt;bellman_ford&lt;/span&gt;();
    &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (dist[n] &amp;gt; &lt;span class=&#34;number&#34;&gt;0x1f1f1f1f&lt;/span&gt;) &amp;#123;
        cout &amp;lt;&amp;lt; &lt;span class=&#34;string&#34;&gt;&amp;quot;impossible&amp;quot;&lt;/span&gt; &amp;lt;&amp;lt; endl;
    &amp;#125; &lt;span class=&#34;keyword&#34;&gt;else&lt;/span&gt; &amp;#123;
        cout &amp;lt;&amp;lt; dist[n] &amp;lt;&amp;lt; endl;
    &amp;#125;
    &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;SPFA-算法&#34;&gt;SPFA 算法&lt;/h3&gt;
&lt;p&gt;SPFA 算法在国际上通称为「队列优化的 Bellman-Ford 算法」，时间复杂度一般情况下为 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo stretchy=&#34;false&#34;&gt;(&lt;/mo&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mo stretchy=&#34;false&#34;&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;O(m)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; ，最坏情况下为 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo stretchy=&#34;false&#34;&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mo stretchy=&#34;false&#34;&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;O(nm)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 。&lt;/p&gt;
&lt;h4 id=&#34;实现-4&#34;&gt;实现&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;先初始化一个队列，并将起点入队。&lt;/li&gt;
&lt;li&gt;一直循环直到队列为空：
&lt;ol&gt;
&lt;li&gt;取出队头，设其为 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;t&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.61508em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;t&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 并出队。&lt;/li&gt;
&lt;li&gt;如果 &lt;code&gt;dist[t]&lt;/code&gt; 可以变小，则更新 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;t&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.61508em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;t&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 的所有出边 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mover&gt;&lt;mo stretchy=&#34;true&#34;&gt;→&lt;/mo&gt;&lt;mpadded width=&#34;+0.6em&#34; lspace=&#34;0.3em&#34;&gt;&lt;mi&gt;w&lt;/mi&gt;&lt;/mpadded&gt;&lt;/mover&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;t \xrightarrow{w} b&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.934392em;vertical-align:-0.01100000000000001em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel x-arrow&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.923392em;&#34;&gt;&lt;span style=&#34;top:-3.322em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight x-arrow-pad&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathnormal mtight&#34; style=&#34;margin-right:0.02691em;&#34;&gt;w&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;svg-align&#34; style=&#34;top:-2.689em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;hide-tail&#34; style=&#34;height:0.522em;min-width:1.469em;&#34;&gt;&lt;svg width=&#39;400em&#39; height=&#39;0.522em&#39; viewBox=&#39;0 0 400000 522&#39; preserveAspectRatio=&#39;xMaxYMin slice&#39;&gt;&lt;path d=&#39;M0 241v40h399891c-47.3 35.3-84 78-110 128
-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20
 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7
 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85
-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
 151.7 139 205zm0 0v40h399900v-40z&#39;/&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.01100000000000001em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;b&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; ，如果更新成功将 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;b&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;b&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 加入队列。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;SPFA-判负环&#34;&gt;SPFA 判负环&lt;/h4&gt;
&lt;p&gt;在每次更新 &lt;code&gt;dist[x]&lt;/code&gt; 的同时记录当前所走过的边数 &lt;code&gt;cnt[x] = cnt[t] + 1&lt;/code&gt; ，若 &lt;code&gt;cnt[n]&lt;/code&gt; 大于等于 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;n&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;n&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 则可以证明存在图中负环。&lt;/p&gt;
&lt;p&gt;由于从 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;1&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 号点开始走不能保证走到所有的负环，因此需要将节点 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;∼&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;1 \sim n&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;∼&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;n&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 都入队进行查找。&lt;/p&gt;
&lt;h4 id=&#34;卡-SPFA&#34;&gt;卡 SPFA&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;生成一棵以起点为根的树，树高尽量高（比如 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;1&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 为起点时，可以令每个点 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;i&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.65952em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 的父亲在 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;max&lt;/mi&gt;&lt;mo&gt;⁡&lt;/mo&gt;&lt;mo stretchy=&#34;false&#34;&gt;(&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;5&lt;/mn&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo stretchy=&#34;false&#34;&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;\max(i - 5, 1)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mop&#34;&gt;max&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 到 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;i - 1&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.74285em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 随机），边权随机，作为最短路径树，同时直接递推求出每个点的带权深度 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;d_i&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.84444em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.31166399999999994em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathnormal mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;对于剩下的边，端点 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo stretchy=&#34;false&#34;&gt;(&lt;/mo&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mo stretchy=&#34;false&#34;&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;(a, b)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 随机，边权在 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;∣&lt;/mi&gt;&lt;msub&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;/msub&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;/msub&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;∣&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;|d_b - d_a|&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;∣&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.33610799999999996em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathnormal mtight&#34;&gt;b&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.151392em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathnormal mtight&#34;&gt;a&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;∣&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 到 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;∣&lt;/mi&gt;&lt;msub&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;/msub&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;/msub&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;∣&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;5&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;|d_b - d_a| + 5&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;∣&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.33610799999999996em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathnormal mtight&#34;&gt;b&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.151392em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathnormal mtight&#34;&gt;a&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;∣&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;5&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 随机（如果是有向图则去掉绝对值符号， &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;5&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;5&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;5&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 可以换成其他较小的正数）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这样生成的图中，次短路的条数非常的多，而 SPFA 一旦错误地进入了次短路的分支，就会使得一整棵子树被赋错误的距离，从而在后期不得不重新更新。而由于边权接近，剪枝的效果会受到很大影响。&lt;/p&gt;
&lt;h4 id=&#34;代码-4&#34;&gt;代码&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;SPFA 求最短路&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;题目：&lt;a href=&#34;https://www.acwing.com/problem/content/853/&#34;&gt;851. spfa求最短路 - AcWing&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;highlight cpp&#34;&gt;&lt;span class=&#34;meta&#34;&gt;#&lt;span class=&#34;meta-keyword&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;meta-string&#34;&gt;&amp;lt;bits/stdc++.h&amp;gt;&lt;/span&gt;&lt;/span&gt;

&lt;span class=&#34;keyword&#34;&gt;using&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;namespace&lt;/span&gt; std;

&lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; n, m, u, v, w, dist[&lt;span class=&#34;number&#34;&gt;100005&lt;/span&gt;];
vector&amp;lt;pair&amp;lt;&lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt;, &lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt;&amp;gt;&amp;gt; g[&lt;span class=&#34;number&#34;&gt;100005&lt;/span&gt;];

&lt;span class=&#34;function&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;spfa&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;
    &lt;span class=&#34;built_in&#34;&gt;memset&lt;/span&gt;(dist, &lt;span class=&#34;number&#34;&gt;0x3f&lt;/span&gt;, &lt;span class=&#34;built_in&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;sizeof&lt;/span&gt;&lt;/span&gt;(dist));
    dist[&lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;] = &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;;
    queue&amp;lt;&lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt;&amp;gt; q;
    q.&lt;span class=&#34;built_in&#34;&gt;push&lt;/span&gt;(&lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;);
    &lt;span class=&#34;keyword&#34;&gt;while&lt;/span&gt; (!q.&lt;span class=&#34;built_in&#34;&gt;empty&lt;/span&gt;()) &amp;#123;
        &lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; t = q.&lt;span class=&#34;built_in&#34;&gt;front&lt;/span&gt;();
        q.&lt;span class=&#34;built_in&#34;&gt;pop&lt;/span&gt;();
        &lt;span class=&#34;keyword&#34;&gt;for&lt;/span&gt; (&lt;span class=&#34;keyword&#34;&gt;auto&lt;/span&gt; i : g[t]) &amp;#123;
            &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (dist[i.first] &amp;gt; dist[t] + i.second) &amp;#123;
                dist[i.first] = dist[t] + i.second;
                q.&lt;span class=&#34;built_in&#34;&gt;push&lt;/span&gt;(i.first);
            &amp;#125;
        &amp;#125;
    &amp;#125;
&amp;#125;

&lt;span class=&#34;function&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    &lt;span class=&#34;keyword&#34;&gt;for&lt;/span&gt; (&lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; i = &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;; i &amp;lt; m; i++) &amp;#123;
        cin &amp;gt;&amp;gt; u &amp;gt;&amp;gt; v &amp;gt;&amp;gt; w;
        g[u].&lt;span class=&#34;built_in&#34;&gt;push_back&lt;/span&gt;(&lt;span class=&#34;built_in&#34;&gt;make_pair&lt;/span&gt;(v, w));
    &amp;#125;
    &lt;span class=&#34;built_in&#34;&gt;spfa&lt;/span&gt;();
    &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (dist[n] == &lt;span class=&#34;number&#34;&gt;0x3f3f3f3f&lt;/span&gt;) &amp;#123;
        cout &amp;lt;&amp;lt; &lt;span class=&#34;string&#34;&gt;&amp;quot;impossible&amp;quot;&lt;/span&gt; &amp;lt;&amp;lt; endl;
    &amp;#125; &lt;span class=&#34;keyword&#34;&gt;else&lt;/span&gt; &amp;#123;
        cout &amp;lt;&amp;lt; dist[n] &amp;lt;&amp;lt; endl;
    &amp;#125;
    &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;SPFA 判负环&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;题目：&lt;a href=&#34;https://www.acwing.com/problem/content/854/&#34;&gt;852. spfa判断负环 - AcWing&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;highlight cpp&#34;&gt;&lt;span class=&#34;meta&#34;&gt;#&lt;span class=&#34;meta-keyword&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;meta-string&#34;&gt;&amp;lt;bits/stdc++.h&amp;gt;&lt;/span&gt;&lt;/span&gt;

&lt;span class=&#34;keyword&#34;&gt;using&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;namespace&lt;/span&gt; std;

&lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; n, m, u, v, w, dist[&lt;span class=&#34;number&#34;&gt;100005&lt;/span&gt;], cnt[&lt;span class=&#34;number&#34;&gt;100005&lt;/span&gt;];
vector&amp;lt;pair&amp;lt;&lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt;, &lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt;&amp;gt;&amp;gt; g[&lt;span class=&#34;number&#34;&gt;100005&lt;/span&gt;];

&lt;span class=&#34;function&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;bool&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;spfa&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;
    &lt;span class=&#34;built_in&#34;&gt;memset&lt;/span&gt;(dist, &lt;span class=&#34;number&#34;&gt;0x3f&lt;/span&gt;, &lt;span class=&#34;built_in&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;sizeof&lt;/span&gt;&lt;/span&gt;(dist));
    queue&amp;lt;&lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt;&amp;gt; q;
    &lt;span class=&#34;keyword&#34;&gt;for&lt;/span&gt; (&lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; i = &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;; i &amp;lt;= n; i++) &amp;#123;
        q.&lt;span class=&#34;built_in&#34;&gt;push&lt;/span&gt;(i);
    &amp;#125;
    &lt;span class=&#34;keyword&#34;&gt;while&lt;/span&gt; (!q.&lt;span class=&#34;built_in&#34;&gt;empty&lt;/span&gt;()) &amp;#123;
        &lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; t = q.&lt;span class=&#34;built_in&#34;&gt;front&lt;/span&gt;();
        q.&lt;span class=&#34;built_in&#34;&gt;pop&lt;/span&gt;();
        &lt;span class=&#34;keyword&#34;&gt;for&lt;/span&gt; (&lt;span class=&#34;keyword&#34;&gt;auto&lt;/span&gt; i : g[t]) &amp;#123;
            &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (dist[i.first] &amp;gt; dist[t] + i.second) &amp;#123;
                dist[i.first] = dist[t] + i.second;
                cnt[i.first] = cnt[t] + &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;;
                &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (cnt[i.first] &amp;gt;= n) &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;literal&#34;&gt;true&lt;/span&gt;;
                q.&lt;span class=&#34;built_in&#34;&gt;push&lt;/span&gt;(i.first);
            &amp;#125;
        &amp;#125;
    &amp;#125;
    &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;literal&#34;&gt;false&lt;/span&gt;;
&amp;#125;

&lt;span class=&#34;function&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    &lt;span class=&#34;keyword&#34;&gt;for&lt;/span&gt; (&lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; i = &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;; i &amp;lt; m; i++) &amp;#123;
        cin &amp;gt;&amp;gt; u &amp;gt;&amp;gt; v &amp;gt;&amp;gt; w;
        g[u].&lt;span class=&#34;built_in&#34;&gt;push_back&lt;/span&gt;(&lt;span class=&#34;built_in&#34;&gt;make_pair&lt;/span&gt;(v, w));
    &amp;#125;
    cout &amp;lt;&amp;lt; (&lt;span class=&#34;built_in&#34;&gt;spfa&lt;/span&gt;() ? &lt;span class=&#34;string&#34;&gt;&amp;quot;Yes&amp;quot;&lt;/span&gt; : &lt;span class=&#34;string&#34;&gt;&amp;quot;No&amp;quot;&lt;/span&gt;) &amp;lt;&amp;lt; endl;
    &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;确定终点的最短路径问题&#34;&gt;确定终点的最短路径问题&lt;/h2&gt;
&lt;p&gt;与确定起点的问题相反，该问题是已知终结节点，求最短路径的问题。在无向图中该问题与确定起点的问题完全等同，在有向图中该问题等同于把所有路径方向反转的确定起点的问题。&lt;/p&gt;
&lt;p&gt;只需要反向存图然后再跑一遍单源最短路即可。&lt;/p&gt;
&lt;h2 id=&#34;确定起点终点的最短路径问题&#34;&gt;确定起点终点的最短路径问题&lt;/h2&gt;
&lt;p&gt;即已知起点和终点，求两节点之间的最短路径。&lt;/p&gt;
&lt;p&gt;可以使用单源最短路算法并进行剪枝：在处理完到终点的最短路径后直接停止计算最短路。&lt;/p&gt;
&lt;h2 id=&#34;全局最短路径问题&#34;&gt;全局最短路径问题&lt;/h2&gt;
&lt;p&gt;也叫多源最短路问题，求图中所有的最短路径。适合使用 Floyd 算法，时间复杂度为 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo stretchy=&#34;false&#34;&gt;(&lt;/mo&gt;&lt;msup&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;/msup&gt;&lt;mo stretchy=&#34;false&#34;&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;O(n^3)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.064108em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 。&lt;/p&gt;
&lt;h3 id=&#34;实现-5&#34;&gt;实现&lt;/h3&gt;
&lt;p&gt;定义一个三维数组 &lt;code&gt;f[k][x][y]&lt;/code&gt; ，表示只允许从 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;x&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;x&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 点经过节点 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;∼&lt;/mo&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;1 \sim k&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;∼&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 点到 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;y&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.625em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 点的最短距离，那么很容易得出从 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;1&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 点到 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;n&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;n&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 点的最短路径为 &lt;code&gt;f[n][1][n]&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;之后使用三重循环枚举即可。&lt;/p&gt;
&lt;h3 id=&#34;代码-5&#34;&gt;代码&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;highlight cpp&#34;&gt;&lt;span class=&#34;meta&#34;&gt;#&lt;span class=&#34;meta-keyword&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;meta-string&#34;&gt;&amp;lt;bits/stdc++.h&amp;gt;&lt;/span&gt;&lt;/span&gt;

&lt;span class=&#34;keyword&#34;&gt;using&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;namespace&lt;/span&gt; std;

&lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; n, m, k, x, y, z, f[&lt;span class=&#34;number&#34;&gt;205&lt;/span&gt;][&lt;span class=&#34;number&#34;&gt;205&lt;/span&gt;];

&lt;span class=&#34;function&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m &amp;gt;&amp;gt; k;
    &lt;span class=&#34;keyword&#34;&gt;for&lt;/span&gt; (&lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; i = &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;; i &amp;lt;= n; i++) &amp;#123;
        &lt;span class=&#34;keyword&#34;&gt;for&lt;/span&gt; (&lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; j = &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;; j &amp;lt;= n; j++) &amp;#123;
            f[i][j] = i == j ? &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt; : &lt;span class=&#34;number&#34;&gt;0x3f3f3f3f3f&lt;/span&gt;;
        &amp;#125;
    &amp;#125;
    &lt;span class=&#34;keyword&#34;&gt;for&lt;/span&gt; (&lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; i = &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;; i &amp;lt;= m; i++) &amp;#123;
        cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y &amp;gt;&amp;gt; z;
        f[x][y] = &lt;span class=&#34;built_in&#34;&gt;min&lt;/span&gt;(f[x][y], z);
    &amp;#125;
    &lt;span class=&#34;keyword&#34;&gt;for&lt;/span&gt; (&lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; k = &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;; k &amp;lt;= n; k++) &amp;#123;
        &lt;span class=&#34;keyword&#34;&gt;for&lt;/span&gt; (&lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; i = &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;; i &amp;lt;= n; i++) &amp;#123;
            &lt;span class=&#34;keyword&#34;&gt;for&lt;/span&gt; (&lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; j = &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;; j &amp;lt;= n; j++) &amp;#123;
                f[i][j] = &lt;span class=&#34;built_in&#34;&gt;min&lt;/span&gt;(f[i][j], f[i][k] + f[k][j]);
            &amp;#125;
        &amp;#125;
    &amp;#125;
    &lt;span class=&#34;keyword&#34;&gt;for&lt;/span&gt; (&lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; i = &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;; i &amp;lt;= k; i++) &amp;#123;
        cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y;
        &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (f[x][y] &amp;gt; &lt;span class=&#34;number&#34;&gt;0x1fffffff&lt;/span&gt;) &amp;#123;
            cout &amp;lt;&amp;lt; &lt;span class=&#34;string&#34;&gt;&amp;quot;impossible&amp;quot;&lt;/span&gt; &amp;lt;&amp;lt; endl;
        &amp;#125; &lt;span class=&#34;keyword&#34;&gt;else&lt;/span&gt; &amp;#123;
            cout &amp;lt;&amp;lt; f[x][y] &amp;lt;&amp;lt; endl;
        &amp;#125;
    &amp;#125;
    &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://oi-wiki.org/graph/shortest-path/&#34;&gt;最短路 - 图论 - OI Wiki&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98&#34;&gt;最短路问题 - 维基百科&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E6%88%B4%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95&#34;&gt;戴克斯特拉算法 (Dijkstra 算法) - 维基百科&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/Floyd-Warshall%E7%AE%97%E6%B3%95&#34;&gt;Floyd-Warshall 算法 - 维基百科&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E8%B4%9D%E5%B0%94%E6%9B%BC-%E7%A6%8F%E7%89%B9%E7%AE%97%E6%B3%95&#34;&gt;Bellman-ford 算法 - 维基百科&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.zhihu.com/question/292283275/answer/484694411&#34;&gt;如何看待 SPFA 算法已死这种说法？ - immortalCO 的回答 - 知乎&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;em&gt;（文章头图来自《啊哈！算法》）&lt;/em&gt;&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://blog.baoshuo.ren/post/segment-tree/</guid>
            <title>线段树学习笔记</title>
            <link>https://blog.baoshuo.ren/post/segment-tree/</link>
            <category>笔记</category>
            <pubDate>Wed, 02 Dec 2020 08:08:39 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;线段树（Segment Tree）是一种用来维护区间的数据结构。&lt;/p&gt;
&lt;a id=&#34;more&#34;&gt;&lt;/a&gt;
&lt;p&gt;与树状数组相比，线段树可以实现时间复杂度在 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo stretchy=&#34;false&#34;&gt;(&lt;/mo&gt;&lt;mi&gt;log&lt;/mi&gt;&lt;mo&gt;⁡&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo stretchy=&#34;false&#34;&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;O(\log n)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mop&#34;&gt;lo&lt;span style=&#34;margin-right:0.01389em;&#34;&gt;g&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 级别的区间修改，还可以同时支持多种操作（加、乘、最值等）。&lt;/p&gt;
&lt;h2 id=&#34;操作列表&#34;&gt;操作列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;上传（pushup）&lt;/li&gt;
&lt;li&gt;建树（build）&lt;/li&gt;
&lt;li&gt;下放懒标记（pushdown）&lt;/li&gt;
&lt;li&gt;区间查询（query）&lt;/li&gt;
&lt;li&gt;区间修改（modify）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;通用操作&#34;&gt;通用操作&lt;/h2&gt;
&lt;h3 id=&#34;存储线段树&#34;&gt;存储线段树&lt;/h3&gt;
&lt;p&gt;线段树是一个典型的二叉树，因此我们可以使用一个数组来存储线段树。&lt;/p&gt;
&lt;p&gt;分析：很容易就知道线段树的深度为 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo stretchy=&#34;false&#34;&gt;⌈&lt;/mo&gt;&lt;mi&gt;log&lt;/mi&gt;&lt;mo&gt;⁡&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo stretchy=&#34;false&#34;&gt;⌉&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;\lceil\log n\rceil&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;⌈&lt;/span&gt;&lt;span class=&#34;mop&#34;&gt;lo&lt;span style=&#34;margin-right:0.01389em;&#34;&gt;g&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;⌉&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; ，可得线段树的节点个数为 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msup&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mo fence=&#34;true&#34;&gt;⌈&lt;/mo&gt;&lt;mi&gt;log&lt;/mi&gt;&lt;mo&gt;⁡&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo fence=&#34;true&#34;&gt;⌉&lt;/mo&gt;&lt;/mrow&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;/msup&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;2^{\left\lceil\log{n}\right\rceil+1}-1&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.9713299999999999em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8879999999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;minner mtight&#34;&gt;&lt;span class=&#34;mopen mtight delimcenter&#34; style=&#34;top:0em;&#34;&gt;&lt;span class=&#34;mtight&#34;&gt;⌈&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mop mtight&#34;&gt;&lt;span class=&#34;mtight&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mtight&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mtight&#34; style=&#34;margin-right:0.01389em;&#34;&gt;g&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace mtight&#34; style=&#34;margin-right:0.19516666666666668em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathnormal mtight&#34;&gt;n&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose mtight delimcenter&#34; style=&#34;top:0em;&#34;&gt;&lt;span class=&#34;mtight&#34;&gt;⌉&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mbin mtight&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，粗略估计开大小为 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;4&lt;/mn&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;4n&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;n&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 的数组即可（可以使用位运算写成 &lt;code&gt;n &amp;lt;&amp;lt; 2&lt;/code&gt;）。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;highlight cpp&#34;&gt;&lt;span class=&#34;class&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;node&lt;/span&gt; &amp;#123;&lt;/span&gt;
    &lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; l, r;
    &lt;span class=&#34;keyword&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;long&lt;/span&gt; s, d;

    &lt;span class=&#34;built_in&#34;&gt;node&lt;/span&gt;() &amp;#123;
        l = r = s = d = &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;;
    &amp;#125;
    &lt;span class=&#34;built_in&#34;&gt;node&lt;/span&gt;(&lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; _l, &lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; _r) &amp;#123;
        l = _l;
        r = _r;
        s = d = &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;;
    &amp;#125;
&amp;#125; tr[&lt;span class=&#34;number&#34;&gt;100005&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&#34;number&#34;&gt;2&lt;/span&gt;];&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;变量名&lt;/th&gt;
&lt;th&gt;用途&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;l&lt;/td&gt;
&lt;td&gt;区间的左端点&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;r&lt;/td&gt;
&lt;td&gt;区间的右端点&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;s&lt;/td&gt;
&lt;td&gt;区间和&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;d&lt;/td&gt;
&lt;td&gt;懒标记&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;上传（pushup）&#34;&gt;上传（pushup）&lt;/h3&gt;
&lt;p&gt;之所以把上传放在建树前面说，是因为建树的时候要用到它。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;highlight cpp&#34;&gt;&lt;span class=&#34;comment&#34;&gt;/**&lt;/span&gt;
&lt;span class=&#34;comment&#34;&gt; * 上传信息&lt;/span&gt;
&lt;span class=&#34;comment&#34;&gt; * @param u 父节点下标&lt;/span&gt;
&lt;span class=&#34;comment&#34;&gt; */&lt;/span&gt;
&lt;span class=&#34;function&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;inline&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;pushup&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(&lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; u)&lt;/span&gt; &lt;/span&gt;&amp;#123;
    tr[u].s = tr[u &amp;lt;&amp;lt; &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;].s + tr[u &amp;lt;&amp;lt; &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt; | &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;].s;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将两个子节点所代表的区间的和相加即为父区间的和。&lt;/p&gt;
&lt;h3 id=&#34;建树（build）&#34;&gt;建树（build）&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;highlight cpp&#34;&gt;&lt;span class=&#34;comment&#34;&gt;/**&lt;/span&gt;
&lt;span class=&#34;comment&#34;&gt; * 建立线段树&lt;/span&gt;
&lt;span class=&#34;comment&#34;&gt; * @param u 根节点下标&lt;/span&gt;
&lt;span class=&#34;comment&#34;&gt; * @param l 左端点&lt;/span&gt;
&lt;span class=&#34;comment&#34;&gt; * @param r 右端点&lt;/span&gt;
&lt;span class=&#34;comment&#34;&gt; */&lt;/span&gt;
&lt;span class=&#34;function&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;build&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(&lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; u, &lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; l, &lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; r)&lt;/span&gt; &lt;/span&gt;&amp;#123;
    tr[u] = &lt;span class=&#34;built_in&#34;&gt;node&lt;/span&gt;(l, r);
    &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (l == r) &amp;#123;
        tr[u].s = a[l];
        &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt;;
    &amp;#125;
    &lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; mid = l + r &amp;gt;&amp;gt; &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;;
    &lt;span class=&#34;built_in&#34;&gt;build&lt;/span&gt;(u &amp;lt;&amp;lt; &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;, l, mid);
    &lt;span class=&#34;built_in&#34;&gt;build&lt;/span&gt;(u &amp;lt;&amp;lt; &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt; | &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;, mid + &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;, r);
    &lt;span class=&#34;built_in&#34;&gt;pushup&lt;/span&gt;(u);
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;先初始化当前区间，接下来分两种情况：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;若当前区间长度等于 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mtext&gt;  &lt;/mtext&gt;&lt;mo stretchy=&#34;false&#34;&gt;(&lt;/mo&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mo stretchy=&#34;false&#34;&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;1\ \ (l = r)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; ，则直接将当前区间的区间和赋值为 &lt;code&gt;a[l]&lt;/code&gt; 即可。&lt;/li&gt;
&lt;li&gt;若当前区间长度大于 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mtext&gt;  &lt;/mtext&gt;&lt;mo stretchy=&#34;false&#34;&gt;(&lt;/mo&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mo&gt;&amp;lt;&lt;/mo&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mo stretchy=&#34;false&#34;&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;1\ \ (l &amp;lt; r)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; ，则将区间平均分成两部分（即从 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo stretchy=&#34;false&#34;&gt;⌊&lt;/mo&gt;&lt;mo stretchy=&#34;false&#34;&gt;(&lt;/mo&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mo stretchy=&#34;false&#34;&gt;)&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;/&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mo stretchy=&#34;false&#34;&gt;⌋&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;\lfloor(l+r)/2\rfloor&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;⌊&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;⌋&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 处断开分为两个区间，可写作 &lt;code&gt;l + r &amp;gt;&amp;gt; 1&lt;/code&gt;），继续向下递归建立左右子树即可。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;需要注意的是两个子区间没有交集，因此左子树的左端点是 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;l&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 、右端点是 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;mid&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;d&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; ，右子树的左端点是 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;mid+1&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.77777em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 、右端点是 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;r&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 。&lt;/p&gt;
&lt;h3 id=&#34;区间查询（query）&#34;&gt;区间查询（query）&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;highlight cpp&#34;&gt;&lt;span class=&#34;comment&#34;&gt;/**&lt;/span&gt;
&lt;span class=&#34;comment&#34;&gt; * 区间查询&lt;/span&gt;
&lt;span class=&#34;comment&#34;&gt; * @param u 父节点&lt;/span&gt;
&lt;span class=&#34;comment&#34;&gt; * @param l 左端点&lt;/span&gt;
&lt;span class=&#34;comment&#34;&gt; * @param r 右端点&lt;/span&gt;
&lt;span class=&#34;comment&#34;&gt; */&lt;/span&gt;
&lt;span class=&#34;function&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;query&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(&lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; u, &lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; l, &lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; r)&lt;/span&gt; &lt;/span&gt;&amp;#123;
    &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (tr[u].l &amp;gt;= l &amp;amp;&amp;amp; tr[u].r &amp;lt;= r) &amp;#123;  &lt;span class=&#34;comment&#34;&gt;// 被包含直接返回当前区间和&lt;/span&gt;
        &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; tr[u].s;
    &amp;#125;
    &lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; mid = tr[u].l + tr[u].r &amp;gt;&amp;gt; &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;;
    &lt;span class=&#34;keyword&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;long&lt;/span&gt; s = &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;;
    &lt;span class=&#34;built_in&#34;&gt;pushdown&lt;/span&gt;(u);                                &lt;span class=&#34;comment&#34;&gt;// 下放懒标记&lt;/span&gt;
    &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (l &amp;lt;= mid) s += &lt;span class=&#34;built_in&#34;&gt;query&lt;/span&gt;(u &amp;lt;&amp;lt; &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;, l, r);     &lt;span class=&#34;comment&#34;&gt;// 和左侧有交集&lt;/span&gt;
    &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (r &amp;gt; mid) s += &lt;span class=&#34;built_in&#34;&gt;query&lt;/span&gt;(u &amp;lt;&amp;lt; &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt; | &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;, l, r);  &lt;span class=&#34;comment&#34;&gt;// 和右侧有交集&lt;/span&gt;
    &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; s;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;如果这个区间被包含，直接返回该区间的和。&lt;/li&gt;
&lt;li&gt;如果和左儿子区间有交集，则继续向左儿子区间递归查询。&lt;/li&gt;
&lt;li&gt;如果和右儿子区间有交集，则继续向右儿子区间递归查询。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;需要注意的是在递归查询左右儿子区间之前要先下放懒标记（pushdown），否则会出问题。&lt;/p&gt;
&lt;h2 id=&#34;区间加&#34;&gt;区间加&lt;/h2&gt;
&lt;p&gt;本部分以 &lt;a href=&#34;https://www.luogu.com.cn/problem/P3372&#34;&gt;洛谷 P3372 【模板】线段树 1&lt;/a&gt; 为例子来简述一下线段树区间加的实现。&lt;/p&gt;
&lt;h3 id=&#34;下放懒标记（pushdown）&#34;&gt;下放懒标记（pushdown）&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;highlight cpp&#34;&gt;&lt;span class=&#34;comment&#34;&gt;/**&lt;/span&gt;
&lt;span class=&#34;comment&#34;&gt; * 下放懒标记&lt;/span&gt;
&lt;span class=&#34;comment&#34;&gt; * @param u 父节点下标&lt;/span&gt;
&lt;span class=&#34;comment&#34;&gt; */&lt;/span&gt;
&lt;span class=&#34;function&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;inline&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;pushdown&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(&lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; u)&lt;/span&gt; &lt;/span&gt;&amp;#123;
    &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (!tr[u].d) &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt;;
    &lt;span class=&#34;comment&#34;&gt;// 处理左子树&lt;/span&gt;
    tr[u &amp;lt;&amp;lt; &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;].d += tr[u].d;
    tr[u &amp;lt;&amp;lt; &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;].s += (tr[u &amp;lt;&amp;lt; &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;].r - tr[u &amp;lt;&amp;lt; &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;].l + &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;) * tr[u].d;
    &lt;span class=&#34;comment&#34;&gt;// 处理右子树&lt;/span&gt;
    tr[u &amp;lt;&amp;lt; &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt; | &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;].d += tr[u].d;
    tr[u &amp;lt;&amp;lt; &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt; | &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;].s += (tr[u &amp;lt;&amp;lt; &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt; | &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;].r - tr[u &amp;lt;&amp;lt; &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt; | &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;].l + &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;) * tr[u].d;
    &lt;span class=&#34;comment&#34;&gt;// 清除懒标记&lt;/span&gt;
    tr[u].d = &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这部分代码其实很简单。&lt;/p&gt;
&lt;p&gt;将左、右子树的懒标记加上父节点的懒标记，区间和加上 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo stretchy=&#34;false&#34;&gt;(&lt;/mo&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo stretchy=&#34;false&#34;&gt;)&lt;/mo&gt;&lt;mo&gt;×&lt;/mo&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;(r - l + 1)\times d&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.77777em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;×&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;d&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; （&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;r, l&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8888799999999999em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 分别表示儿子区间的左、右端点，&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;d&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;d&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;表示父节点的懒标记），最后清空父节点的懒标记即可。&lt;/p&gt;
&lt;h3 id=&#34;区间修改（modify）&#34;&gt;区间修改（modify）&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;highlight cpp&#34;&gt;&lt;span class=&#34;comment&#34;&gt;/**&lt;/span&gt;
&lt;span class=&#34;comment&#34;&gt; * 区间修改&lt;/span&gt;
&lt;span class=&#34;comment&#34;&gt; * @param u 父节点下标&lt;/span&gt;
&lt;span class=&#34;comment&#34;&gt; * @param l 左端点&lt;/span&gt;
&lt;span class=&#34;comment&#34;&gt; * @param r 右端点&lt;/span&gt;
&lt;span class=&#34;comment&#34;&gt; * @param d 增加的值&lt;/span&gt;
&lt;span class=&#34;comment&#34;&gt; */&lt;/span&gt;
&lt;span class=&#34;function&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;modify&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(&lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; u, &lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; l, &lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; r, &lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; d)&lt;/span&gt; &lt;/span&gt;&amp;#123;
    &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (tr[u].l &amp;gt;= l &amp;amp;&amp;amp; tr[u].r &amp;lt;= r) &amp;#123;  &lt;span class=&#34;comment&#34;&gt;// 被包含直接修改&lt;/span&gt;
        tr[u].d += d;
        tr[u].s += (tr[u].r - tr[u].l + &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;) * d;
        &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt;;
    &amp;#125;
    &lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; mid = tr[u].l + tr[u].r &amp;gt;&amp;gt; &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;;
    &lt;span class=&#34;built_in&#34;&gt;pushdown&lt;/span&gt;(u);                               &lt;span class=&#34;comment&#34;&gt;// 下放懒标记&lt;/span&gt;
    &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (l &amp;lt;= mid) &lt;span class=&#34;built_in&#34;&gt;modify&lt;/span&gt;(u &amp;lt;&amp;lt; &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;, l, r, d);     &lt;span class=&#34;comment&#34;&gt;// 和左侧有交集&lt;/span&gt;
    &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (r &amp;gt; mid) &lt;span class=&#34;built_in&#34;&gt;modify&lt;/span&gt;(u &amp;lt;&amp;lt; &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt; | &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;, l, r, d);  &lt;span class=&#34;comment&#34;&gt;// 和右侧有交集&lt;/span&gt;
    &lt;span class=&#34;built_in&#34;&gt;pushup&lt;/span&gt;(u);                                 &lt;span class=&#34;comment&#34;&gt;// 上传新信息&lt;/span&gt;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;区间修改和区间查询的实现相似。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果当前区间被包含，直接添加懒标记并修改区间和。&lt;/li&gt;
&lt;li&gt;如果和左儿子区间有交集，则继续向左儿子区间递归修改。&lt;/li&gt;
&lt;li&gt;如果和右儿子区间有交集，则继续向右儿子区间递归修改。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;需要注意的是在递归修改左右儿子区间之前要先下放懒标记（pushdown），修改完成以后要上传新信息（pushup），否则会出问题。&lt;/p&gt;
&lt;h2 id=&#34;区间加、乘&#34;&gt;区间加、乘&lt;/h2&gt;
&lt;p&gt;本部分以 &lt;a href=&#34;https://www.luogu.com.cn/problem/P3373&#34;&gt;洛谷 P3373 【模板】线段树 2&lt;/a&gt; 为例子来简述一下线段树区间加、乘的实现。&lt;/p&gt;
&lt;p&gt;在编写之前，结构体中需要先添加一个乘法的懒标记 &lt;code&gt;x&lt;/code&gt; ，并将其赋初值为 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;1&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; ，修改之后的结构体如下所示。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;highlight cpp&#34;&gt;&lt;span class=&#34;class&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;node&lt;/span&gt; &amp;#123;&lt;/span&gt;
    &lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; l, r;
    &lt;span class=&#34;keyword&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;long&lt;/span&gt; s, d, x;

    &lt;span class=&#34;built_in&#34;&gt;node&lt;/span&gt;() &amp;#123;
        l = r = s = d = &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;;
        x = &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;;
    &amp;#125;
    &lt;span class=&#34;built_in&#34;&gt;node&lt;/span&gt;(&lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; _l, &lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; _r) &amp;#123;
        l = _l, r = _r;
        s = d = &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;;
        x = &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;;
    &amp;#125;
&amp;#125; tr[&lt;span class=&#34;number&#34;&gt;100005&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&#34;number&#34;&gt;2&lt;/span&gt;];&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;下放懒标记（pushdown）-2&#34;&gt;下放懒标记（pushdown）&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;highlight cpp&#34;&gt;&lt;span class=&#34;comment&#34;&gt;/**&lt;/span&gt;
&lt;span class=&#34;comment&#34;&gt; * 下放懒标记&lt;/span&gt;
&lt;span class=&#34;comment&#34;&gt; * @param u 父节点下标&lt;/span&gt;
&lt;span class=&#34;comment&#34;&gt; * @attention 先乘后加&lt;/span&gt;
&lt;span class=&#34;comment&#34;&gt; */&lt;/span&gt;
&lt;span class=&#34;function&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;pushdown&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(&lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; u)&lt;/span&gt; &lt;/span&gt;&amp;#123;
    &lt;span class=&#34;comment&#34;&gt;// 左子树&lt;/span&gt;
    tr[u &amp;lt;&amp;lt; &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;].s = ((tr[u &amp;lt;&amp;lt; &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;].s * tr[u].x) + (tr[u &amp;lt;&amp;lt; &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;].r - tr[u &amp;lt;&amp;lt; &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;].l + &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;) * tr[u].d) % p;
    tr[u &amp;lt;&amp;lt; &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;].x = tr[u &amp;lt;&amp;lt; &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;].x * tr[u].x % p;
    tr[u &amp;lt;&amp;lt; &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;].d = (tr[u &amp;lt;&amp;lt; &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;].d * tr[u].x + tr[u].d) % p;
    &lt;span class=&#34;comment&#34;&gt;// 右子树&lt;/span&gt;
    tr[u &amp;lt;&amp;lt; &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt; | &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;].s = ((tr[u &amp;lt;&amp;lt; &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt; | &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;].s * tr[u].x) + (tr[u &amp;lt;&amp;lt; &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt; | &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;].r - tr[u &amp;lt;&amp;lt; &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt; | &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;].l + &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;) * tr[u].d) % p;
    tr[u &amp;lt;&amp;lt; &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt; | &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;].x = tr[u &amp;lt;&amp;lt; &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt; | &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;].x * tr[u].x % p;
    tr[u &amp;lt;&amp;lt; &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt; | &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;].d = (tr[u &amp;lt;&amp;lt; &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt; | &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;].d * tr[u].x + tr[u].d) % p;
    &lt;span class=&#34;comment&#34;&gt;// 清除懒标记&lt;/span&gt;
    tr[u].d = &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;;
    tr[u].x = &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此处遵循&lt;strong&gt;先乘后加&lt;/strong&gt;的原则，先修改区间和，再修改乘法懒标记，最后修改加法懒标记，不要忘记 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mo lspace=&#34;0.22em&#34; rspace=&#34;0.22em&#34;&gt;&lt;mrow&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;m&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;o&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;d&lt;/mi&gt;&lt;/mrow&gt;&lt;/mo&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;\bmod\ p&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8888799999999999em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.05555555555555555em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathrm&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathrm&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathrm&#34;&gt;d&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.05555555555555555em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;p&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;注意：此处清除懒标记的时候，乘法懒标记应修改为 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;1&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 。&lt;/p&gt;
&lt;h3 id=&#34;区间修改（modify）-2&#34;&gt;区间修改（modify）&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;highlight cpp&#34;&gt;&lt;span class=&#34;comment&#34;&gt;/**&lt;/span&gt;
&lt;span class=&#34;comment&#34;&gt; * 区间修改&lt;/span&gt;
&lt;span class=&#34;comment&#34;&gt; * @details 修改区间 [l, r] 中的每一个数&lt;/span&gt;
&lt;span class=&#34;comment&#34;&gt; * @param u 父节点下标&lt;/span&gt;
&lt;span class=&#34;comment&#34;&gt; * @param l 左端点&lt;/span&gt;
&lt;span class=&#34;comment&#34;&gt; * @param r 右端点&lt;/span&gt;
&lt;span class=&#34;comment&#34;&gt; * @param x 乘上的数&lt;/span&gt;
&lt;span class=&#34;comment&#34;&gt; * @param d 增加的值&lt;/span&gt;
&lt;span class=&#34;comment&#34;&gt; */&lt;/span&gt;
&lt;span class=&#34;function&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;modify&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(&lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; u, &lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; l, &lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; r, &lt;span class=&#34;keyword&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;long&lt;/span&gt; x, &lt;span class=&#34;keyword&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;long&lt;/span&gt; d)&lt;/span&gt; &lt;/span&gt;&amp;#123;
    &lt;span class=&#34;comment&#34;&gt;// 被包含直接修改&lt;/span&gt;
    &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (tr[u].l &amp;gt;= l &amp;amp;&amp;amp; tr[u].r &amp;lt;= r) &amp;#123;
        tr[u].s = ((tr[u].s * x) + (tr[u].r - tr[u].l + &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;) * d) % p;
        tr[u].x = tr[u].x * x % p;
        tr[u].d = (tr[u].d * x + d) % p;
        &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt;;
    &amp;#125;
    &lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; mid = tr[u].l + tr[u].r &amp;gt;&amp;gt; &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;;
    &lt;span class=&#34;built_in&#34;&gt;pushdown&lt;/span&gt;(u);                                  &lt;span class=&#34;comment&#34;&gt;// 下放懒标记&lt;/span&gt;
    &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (l &amp;lt;= mid) &lt;span class=&#34;built_in&#34;&gt;modify&lt;/span&gt;(u &amp;lt;&amp;lt; &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;, l, r, x, d);     &lt;span class=&#34;comment&#34;&gt;// 和左侧有交集&lt;/span&gt;
    &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (r &amp;gt; mid) &lt;span class=&#34;built_in&#34;&gt;modify&lt;/span&gt;(u &amp;lt;&amp;lt; &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt; | &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;, l, r, x, d);  &lt;span class=&#34;comment&#34;&gt;// 和右侧有交集&lt;/span&gt;
    &lt;span class=&#34;built_in&#34;&gt;pushup&lt;/span&gt;(u);                                    &lt;span class=&#34;comment&#34;&gt;// 上传新信息&lt;/span&gt;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;大体上和加法的修改函数一样，而在修改时与下放懒标记做法相同，遵循&lt;strong&gt;先乘后加&lt;/strong&gt;的原则。&lt;/p&gt;
&lt;p&gt;调用的时候若只需要使用乘法部分，加数设置为 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;0&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 即可。若只需要使用加法部分，乘数设置为 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;1&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 即可。&lt;/p&gt;
&lt;h2 id=&#34;全部代码&#34;&gt;全部代码&lt;/h2&gt;
&lt;p&gt;到这里基本操作就说完了，下面是全部的 AC 代码。&lt;/p&gt;
&lt;h3 id=&#34;区间加-2&#34;&gt;区间加&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;highlight cpp&#34;&gt;&lt;span class=&#34;meta&#34;&gt;#&lt;span class=&#34;meta-keyword&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;meta-string&#34;&gt;&amp;lt;bits/stdc++.h&amp;gt;&lt;/span&gt;&lt;/span&gt;

&lt;span class=&#34;keyword&#34;&gt;using&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;namespace&lt;/span&gt; std;

&lt;span class=&#34;comment&#34;&gt;/**&lt;/span&gt;
&lt;span class=&#34;comment&#34;&gt; * 线段树节点&lt;/span&gt;
&lt;span class=&#34;comment&#34;&gt; */&lt;/span&gt;
&lt;span class=&#34;class&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;node&lt;/span&gt; &amp;#123;&lt;/span&gt;
    &lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; l, r;
    &lt;span class=&#34;keyword&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;long&lt;/span&gt; s, d;

    &lt;span class=&#34;built_in&#34;&gt;node&lt;/span&gt;() &amp;#123;
        l = r = s = d = &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;;
    &amp;#125;
    &lt;span class=&#34;built_in&#34;&gt;node&lt;/span&gt;(&lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; _l, &lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; _r) &amp;#123;
        l = _l;
        r = _r;
        s = d = &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;;
    &amp;#125;
&amp;#125; tr[&lt;span class=&#34;number&#34;&gt;100005&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&#34;number&#34;&gt;2&lt;/span&gt;];
&lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; n, m, op, x, y, k, a[&lt;span class=&#34;number&#34;&gt;100005&lt;/span&gt;];

&lt;span class=&#34;comment&#34;&gt;/**&lt;/span&gt;
&lt;span class=&#34;comment&#34;&gt; * 上传区间和&lt;/span&gt;
&lt;span class=&#34;comment&#34;&gt; * @param u 父节点下标&lt;/span&gt;
&lt;span class=&#34;comment&#34;&gt; */&lt;/span&gt;
&lt;span class=&#34;function&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;pushup&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(&lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; u)&lt;/span&gt; &lt;/span&gt;&amp;#123;
    tr[u].s = tr[u &amp;lt;&amp;lt; &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;].s + tr[u &amp;lt;&amp;lt; &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt; | &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;].s;
&amp;#125;

&lt;span class=&#34;comment&#34;&gt;/**&lt;/span&gt;
&lt;span class=&#34;comment&#34;&gt; * 下放懒标记&lt;/span&gt;
&lt;span class=&#34;comment&#34;&gt; * @param u 父节点下标&lt;/span&gt;
&lt;span class=&#34;comment&#34;&gt; */&lt;/span&gt;
&lt;span class=&#34;function&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;pushdown&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(&lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; u)&lt;/span&gt; &lt;/span&gt;&amp;#123;
    &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (!tr[u].d) &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt;;
    &lt;span class=&#34;comment&#34;&gt;// 处理左子树&lt;/span&gt;
    tr[u &amp;lt;&amp;lt; &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;].d += tr[u].d;
    tr[u &amp;lt;&amp;lt; &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;].s += (tr[u &amp;lt;&amp;lt; &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;].r - tr[u &amp;lt;&amp;lt; &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;].l + &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;) * tr[u].d;
    &lt;span class=&#34;comment&#34;&gt;// 处理右子树&lt;/span&gt;
    tr[u &amp;lt;&amp;lt; &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt; | &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;].d += tr[u].d;
    tr[u &amp;lt;&amp;lt; &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt; | &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;].s += (tr[u &amp;lt;&amp;lt; &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt; | &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;].r - tr[u &amp;lt;&amp;lt; &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt; | &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;].l + &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;) * tr[u].d;
    &lt;span class=&#34;comment&#34;&gt;// 清除懒标记&lt;/span&gt;
    tr[u].d = &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;;
&amp;#125;

&lt;span class=&#34;comment&#34;&gt;/**&lt;/span&gt;
&lt;span class=&#34;comment&#34;&gt; * 建立线段树&lt;/span&gt;
&lt;span class=&#34;comment&#34;&gt; * @param u 根节点下标&lt;/span&gt;
&lt;span class=&#34;comment&#34;&gt; * @param l 左端点&lt;/span&gt;
&lt;span class=&#34;comment&#34;&gt; * @param r 右端点&lt;/span&gt;
&lt;span class=&#34;comment&#34;&gt; */&lt;/span&gt;
&lt;span class=&#34;function&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;build&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(&lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; u, &lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; l, &lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; r)&lt;/span&gt; &lt;/span&gt;&amp;#123;
    tr[u] = &lt;span class=&#34;built_in&#34;&gt;node&lt;/span&gt;(l, r);
    &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (l == r) &amp;#123;
        tr[u].s = a[l];
        &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt;;
    &amp;#125;
    &lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; mid = l + r &amp;gt;&amp;gt; &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;;
    &lt;span class=&#34;built_in&#34;&gt;build&lt;/span&gt;(u &amp;lt;&amp;lt; &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;, l, mid);
    &lt;span class=&#34;built_in&#34;&gt;build&lt;/span&gt;(u &amp;lt;&amp;lt; &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt; | &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;, mid + &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;, r);
    &lt;span class=&#34;built_in&#34;&gt;pushup&lt;/span&gt;(u);
&amp;#125;

&lt;span class=&#34;comment&#34;&gt;/**&lt;/span&gt;
&lt;span class=&#34;comment&#34;&gt; * 区间修改&lt;/span&gt;
&lt;span class=&#34;comment&#34;&gt; * @param u 父节点下标&lt;/span&gt;
&lt;span class=&#34;comment&#34;&gt; * @param l 左端点&lt;/span&gt;
&lt;span class=&#34;comment&#34;&gt; * @param r 右端点&lt;/span&gt;
&lt;span class=&#34;comment&#34;&gt; * @param d 增加的值&lt;/span&gt;
&lt;span class=&#34;comment&#34;&gt; */&lt;/span&gt;
&lt;span class=&#34;function&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;modify&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(&lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; u, &lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; l, &lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; r, &lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; d)&lt;/span&gt; &lt;/span&gt;&amp;#123;
    &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (tr[u].l &amp;gt;= l &amp;amp;&amp;amp; tr[u].r &amp;lt;= r) &amp;#123;  &lt;span class=&#34;comment&#34;&gt;// 被包含直接修改&lt;/span&gt;
        tr[u].d += d;
        tr[u].s += (tr[u].r - tr[u].l + &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;) * d;
        &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt;;
    &amp;#125;
    &lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; mid = tr[u].l + tr[u].r &amp;gt;&amp;gt; &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;;
    &lt;span class=&#34;built_in&#34;&gt;pushdown&lt;/span&gt;(u);                               &lt;span class=&#34;comment&#34;&gt;// 下放懒标记&lt;/span&gt;
    &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (l &amp;lt;= mid) &lt;span class=&#34;built_in&#34;&gt;modify&lt;/span&gt;(u &amp;lt;&amp;lt; &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;, l, r, d);     &lt;span class=&#34;comment&#34;&gt;// 和左侧有交集&lt;/span&gt;
    &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (r &amp;gt; mid) &lt;span class=&#34;built_in&#34;&gt;modify&lt;/span&gt;(u &amp;lt;&amp;lt; &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt; | &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;, l, r, d);  &lt;span class=&#34;comment&#34;&gt;// 和右侧有交集&lt;/span&gt;
    &lt;span class=&#34;built_in&#34;&gt;pushup&lt;/span&gt;(u);                                 &lt;span class=&#34;comment&#34;&gt;// 上传新信息&lt;/span&gt;
&amp;#125;

&lt;span class=&#34;comment&#34;&gt;/**&lt;/span&gt;
&lt;span class=&#34;comment&#34;&gt; * 区间查询&lt;/span&gt;
&lt;span class=&#34;comment&#34;&gt; * @param u 父节点&lt;/span&gt;
&lt;span class=&#34;comment&#34;&gt; * @param l 左端点&lt;/span&gt;
&lt;span class=&#34;comment&#34;&gt; * @param r 右端点&lt;/span&gt;
&lt;span class=&#34;comment&#34;&gt; */&lt;/span&gt;
&lt;span class=&#34;function&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;query&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(&lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; u, &lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; l, &lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; r)&lt;/span&gt; &lt;/span&gt;&amp;#123;
    &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (tr[u].l &amp;gt;= l &amp;amp;&amp;amp; tr[u].r &amp;lt;= r) &amp;#123;  &lt;span class=&#34;comment&#34;&gt;// 被包含直接返回&lt;/span&gt;
        &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; tr[u].s;
    &amp;#125;
    &lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; mid = tr[u].l + tr[u].r &amp;gt;&amp;gt; &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;;
    &lt;span class=&#34;keyword&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;long&lt;/span&gt; s = &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;;
    &lt;span class=&#34;built_in&#34;&gt;pushdown&lt;/span&gt;(u);                                &lt;span class=&#34;comment&#34;&gt;// 下放懒标记&lt;/span&gt;
    &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (l &amp;lt;= mid) s += &lt;span class=&#34;built_in&#34;&gt;query&lt;/span&gt;(u &amp;lt;&amp;lt; &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;, l, r);     &lt;span class=&#34;comment&#34;&gt;// 和左侧有交集&lt;/span&gt;
    &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (r &amp;gt; mid) s += &lt;span class=&#34;built_in&#34;&gt;query&lt;/span&gt;(u &amp;lt;&amp;lt; &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt; | &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;, l, r);  &lt;span class=&#34;comment&#34;&gt;// 和右侧有交集&lt;/span&gt;
    &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; s;
&amp;#125;

&lt;span class=&#34;function&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    &lt;span class=&#34;keyword&#34;&gt;for&lt;/span&gt; (&lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; i = &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;; i &amp;lt;= n; i++) &amp;#123;
        cin &amp;gt;&amp;gt; a[i];
    &amp;#125;
    &lt;span class=&#34;built_in&#34;&gt;build&lt;/span&gt;(&lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;, &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;, n);
    &lt;span class=&#34;keyword&#34;&gt;for&lt;/span&gt; (&lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; i = &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;; i &amp;lt; m; i++) &amp;#123;
        cin &amp;gt;&amp;gt; op &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y;
        &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (op == &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;) &amp;#123;
            cin &amp;gt;&amp;gt; k;
            &lt;span class=&#34;built_in&#34;&gt;modify&lt;/span&gt;(&lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;, x, y, k);
        &amp;#125;
        &lt;span class=&#34;keyword&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (op == &lt;span class=&#34;number&#34;&gt;2&lt;/span&gt;) &amp;#123;
            cout &amp;lt;&amp;lt; &lt;span class=&#34;built_in&#34;&gt;query&lt;/span&gt;(&lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;, x, y) &amp;lt;&amp;lt; endl;
        &amp;#125;
    &amp;#125;
    &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;区间加、乘-2&#34;&gt;区间加、乘&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;highlight cpp&#34;&gt;&lt;span class=&#34;meta&#34;&gt;#&lt;span class=&#34;meta-keyword&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;meta-string&#34;&gt;&amp;lt;bits/stdc++.h&amp;gt;&lt;/span&gt;&lt;/span&gt;

&lt;span class=&#34;keyword&#34;&gt;using&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;namespace&lt;/span&gt; std;

&lt;span class=&#34;class&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;node&lt;/span&gt; &amp;#123;&lt;/span&gt;
    &lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; l, r;
    &lt;span class=&#34;keyword&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;long&lt;/span&gt; s, d, x;

    &lt;span class=&#34;built_in&#34;&gt;node&lt;/span&gt;() &amp;#123;
        l = r = s = d = &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;;
        x = &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;;
    &amp;#125;
    &lt;span class=&#34;built_in&#34;&gt;node&lt;/span&gt;(&lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; _l, &lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; _r) &amp;#123;
        l = _l, r = _r;
        s = d = &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;;
        x = &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;;
    &amp;#125;
&amp;#125; tr[&lt;span class=&#34;number&#34;&gt;100005&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&#34;number&#34;&gt;2&lt;/span&gt;];
&lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; n, m, p, op, x, y;
&lt;span class=&#34;keyword&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;long&lt;/span&gt; k, a[&lt;span class=&#34;number&#34;&gt;100005&lt;/span&gt;];

&lt;span class=&#34;comment&#34;&gt;/**&lt;/span&gt;
&lt;span class=&#34;comment&#34;&gt; * 上传信息&lt;/span&gt;
&lt;span class=&#34;comment&#34;&gt; * @param u 父节点下标&lt;/span&gt;
&lt;span class=&#34;comment&#34;&gt; */&lt;/span&gt;
&lt;span class=&#34;function&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;pushup&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(&lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; u)&lt;/span&gt; &lt;/span&gt;&amp;#123;
    tr[u].s = (tr[u &amp;lt;&amp;lt; &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;].s + tr[u &amp;lt;&amp;lt; &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt; | &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;].s) % p;
&amp;#125;

&lt;span class=&#34;comment&#34;&gt;/**&lt;/span&gt;
&lt;span class=&#34;comment&#34;&gt; * 下放懒标记&lt;/span&gt;
&lt;span class=&#34;comment&#34;&gt; * @param u 父节点下标&lt;/span&gt;
&lt;span class=&#34;comment&#34;&gt; * @attention 先乘后加&lt;/span&gt;
&lt;span class=&#34;comment&#34;&gt; */&lt;/span&gt;
&lt;span class=&#34;function&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;pushdown&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(&lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; u)&lt;/span&gt; &lt;/span&gt;&amp;#123;
    &lt;span class=&#34;comment&#34;&gt;// 左子树&lt;/span&gt;
    tr[u &amp;lt;&amp;lt; &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;].s = ((tr[u &amp;lt;&amp;lt; &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;].s * tr[u].x) + (tr[u &amp;lt;&amp;lt; &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;].r - tr[u &amp;lt;&amp;lt; &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;].l + &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;) * tr[u].d) % p;
    tr[u &amp;lt;&amp;lt; &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;].x = tr[u &amp;lt;&amp;lt; &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;].x * tr[u].x % p;
    tr[u &amp;lt;&amp;lt; &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;].d = (tr[u &amp;lt;&amp;lt; &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;].d * tr[u].x + tr[u].d) % p;
    &lt;span class=&#34;comment&#34;&gt;// 右子树&lt;/span&gt;
    tr[u &amp;lt;&amp;lt; &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt; | &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;].s = ((tr[u &amp;lt;&amp;lt; &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt; | &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;].s * tr[u].x) + (tr[u &amp;lt;&amp;lt; &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt; | &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;].r - tr[u &amp;lt;&amp;lt; &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt; | &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;].l + &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;) * tr[u].d) % p;
    tr[u &amp;lt;&amp;lt; &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt; | &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;].x = tr[u &amp;lt;&amp;lt; &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt; | &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;].x * tr[u].x % p;
    tr[u &amp;lt;&amp;lt; &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt; | &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;].d = (tr[u &amp;lt;&amp;lt; &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt; | &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;].d * tr[u].x + tr[u].d) % p;
    &lt;span class=&#34;comment&#34;&gt;// 清除懒标记&lt;/span&gt;
    tr[u].d = &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;;
    tr[u].x = &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;;
&amp;#125;

&lt;span class=&#34;comment&#34;&gt;/**&lt;/span&gt;
&lt;span class=&#34;comment&#34;&gt; * 建立线段树&lt;/span&gt;
&lt;span class=&#34;comment&#34;&gt; * @param u 根节点下标&lt;/span&gt;
&lt;span class=&#34;comment&#34;&gt; * @param l 左端点&lt;/span&gt;
&lt;span class=&#34;comment&#34;&gt; * @param r 右端点&lt;/span&gt;
&lt;span class=&#34;comment&#34;&gt; */&lt;/span&gt;
&lt;span class=&#34;function&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;build&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(&lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; u, &lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; l, &lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; r)&lt;/span&gt; &lt;/span&gt;&amp;#123;
    tr[u] = &lt;span class=&#34;built_in&#34;&gt;node&lt;/span&gt;(l, r);
    &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (l == r) &amp;#123;
        tr[u].s = a[l] % p;
        &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt;;
    &amp;#125;
    &lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; mid = l + r &amp;gt;&amp;gt; &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;;
    &lt;span class=&#34;built_in&#34;&gt;build&lt;/span&gt;(u &amp;lt;&amp;lt; &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;, l, mid);
    &lt;span class=&#34;built_in&#34;&gt;build&lt;/span&gt;(u &amp;lt;&amp;lt; &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt; | &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;, mid + &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;, r);
    &lt;span class=&#34;built_in&#34;&gt;pushup&lt;/span&gt;(u);
&amp;#125;

&lt;span class=&#34;comment&#34;&gt;/**&lt;/span&gt;
&lt;span class=&#34;comment&#34;&gt; * 区间修改&lt;/span&gt;
&lt;span class=&#34;comment&#34;&gt; * @details 将区间 [l, r] 中的每一个数加上 d&lt;/span&gt;
&lt;span class=&#34;comment&#34;&gt; * @param u 父节点下标&lt;/span&gt;
&lt;span class=&#34;comment&#34;&gt; * @param l 左端点&lt;/span&gt;
&lt;span class=&#34;comment&#34;&gt; * @param r 右端点&lt;/span&gt;
&lt;span class=&#34;comment&#34;&gt; * @param x 乘上的数&lt;/span&gt;
&lt;span class=&#34;comment&#34;&gt; * @param d 增加的值&lt;/span&gt;
&lt;span class=&#34;comment&#34;&gt; */&lt;/span&gt;
&lt;span class=&#34;function&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;modify&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(&lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; u, &lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; l, &lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; r, &lt;span class=&#34;keyword&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;long&lt;/span&gt; x, &lt;span class=&#34;keyword&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;long&lt;/span&gt; d)&lt;/span&gt; &lt;/span&gt;&amp;#123;
    &lt;span class=&#34;comment&#34;&gt;// 被包含直接修改&lt;/span&gt;
    &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (tr[u].l &amp;gt;= l &amp;amp;&amp;amp; tr[u].r &amp;lt;= r) &amp;#123;
        tr[u].s = ((tr[u].s * x) + (tr[u].r - tr[u].l + &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;) * d) % p;
        tr[u].x = tr[u].x * x % p;
        tr[u].d = (tr[u].d * x + d) % p;
        &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt;;
    &amp;#125;
    &lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; mid = tr[u].l + tr[u].r &amp;gt;&amp;gt; &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;;
    &lt;span class=&#34;built_in&#34;&gt;pushdown&lt;/span&gt;(u);                                  &lt;span class=&#34;comment&#34;&gt;// 下放懒标记&lt;/span&gt;
    &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (l &amp;lt;= mid) &lt;span class=&#34;built_in&#34;&gt;modify&lt;/span&gt;(u &amp;lt;&amp;lt; &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;, l, r, x, d);     &lt;span class=&#34;comment&#34;&gt;// 和左侧有交集&lt;/span&gt;
    &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (r &amp;gt; mid) &lt;span class=&#34;built_in&#34;&gt;modify&lt;/span&gt;(u &amp;lt;&amp;lt; &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt; | &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;, l, r, x, d);  &lt;span class=&#34;comment&#34;&gt;// 和右侧有交集&lt;/span&gt;
    &lt;span class=&#34;built_in&#34;&gt;pushup&lt;/span&gt;(u);                                    &lt;span class=&#34;comment&#34;&gt;// 上传新信息&lt;/span&gt;
&amp;#125;

&lt;span class=&#34;comment&#34;&gt;/**&lt;/span&gt;
&lt;span class=&#34;comment&#34;&gt; * 区间查询&lt;/span&gt;
&lt;span class=&#34;comment&#34;&gt; * @param u &lt;/span&gt;
&lt;span class=&#34;comment&#34;&gt; * @param l &lt;/span&gt;
&lt;span class=&#34;comment&#34;&gt; * @param r &lt;/span&gt;
&lt;span class=&#34;comment&#34;&gt; * @return int &lt;/span&gt;
&lt;span class=&#34;comment&#34;&gt; */&lt;/span&gt;
&lt;span class=&#34;function&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;query&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(&lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; u, &lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; l, &lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; r)&lt;/span&gt; &lt;/span&gt;&amp;#123;
    &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (tr[u].l &amp;gt;= l &amp;amp;&amp;amp; tr[u].r &amp;lt;= r) &amp;#123;  &lt;span class=&#34;comment&#34;&gt;// 被包含直接返回&lt;/span&gt;
        &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; tr[u].s;
    &amp;#125;
    &lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; mid = tr[u].l + tr[u].r &amp;gt;&amp;gt; &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;;
    &lt;span class=&#34;keyword&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;long&lt;/span&gt; s = &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;;
    &lt;span class=&#34;built_in&#34;&gt;pushdown&lt;/span&gt;(u);                                         &lt;span class=&#34;comment&#34;&gt;// 下放懒标记&lt;/span&gt;
    &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (l &amp;lt;= mid) s = &lt;span class=&#34;built_in&#34;&gt;query&lt;/span&gt;(u &amp;lt;&amp;lt; &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;, l, r);               &lt;span class=&#34;comment&#34;&gt;// 和左侧有交集&lt;/span&gt;
    &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (r &amp;gt; mid) s = (s + &lt;span class=&#34;built_in&#34;&gt;query&lt;/span&gt;(u &amp;lt;&amp;lt; &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt; | &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;, l, r)) % p;  &lt;span class=&#34;comment&#34;&gt;// 和右侧有交集&lt;/span&gt;
    &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; s;
&amp;#125;

&lt;span class=&#34;function&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m &amp;gt;&amp;gt; p;
    &lt;span class=&#34;keyword&#34;&gt;for&lt;/span&gt; (&lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; i = &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;; i &amp;lt;= n; i++) &amp;#123;
        cin &amp;gt;&amp;gt; a[i];
    &amp;#125;
    &lt;span class=&#34;built_in&#34;&gt;build&lt;/span&gt;(&lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;, &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;, n);
    &lt;span class=&#34;keyword&#34;&gt;while&lt;/span&gt; (m--) &amp;#123;
        cin &amp;gt;&amp;gt; op &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y;
        &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (op == &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;) &amp;#123;
            cin &amp;gt;&amp;gt; k;
            &lt;span class=&#34;built_in&#34;&gt;modify&lt;/span&gt;(&lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;, x, y, k, &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;);
        &amp;#125;
        &lt;span class=&#34;keyword&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (op == &lt;span class=&#34;number&#34;&gt;2&lt;/span&gt;) &amp;#123;
            cin &amp;gt;&amp;gt; k;
            &lt;span class=&#34;built_in&#34;&gt;modify&lt;/span&gt;(&lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;, x, y, &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;, k);
        &amp;#125;
        &lt;span class=&#34;keyword&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (op == &lt;span class=&#34;number&#34;&gt;3&lt;/span&gt;) &amp;#123;
            cout &amp;lt;&amp;lt; &lt;span class=&#34;built_in&#34;&gt;query&lt;/span&gt;(&lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;, x, y) % p &amp;lt;&amp;lt; endl;
        &amp;#125;
    &amp;#125;
    &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;;
&amp;#125;&lt;/code&gt;&lt;/pre&gt; ]]></description>
        </item>
    </channel>
</rss>