{
    "version": "https://jsonfeed.org/version/1",
    "title": "宝硕博客 • All posts by \"笔记\" tag",
    "description": "宝硕博客 —— Baoshuo (@renbaoshuo) 随便写东西的地方，以技术向博文为主，生活向博文为辅。",
    "home_page_url": "https://blog.baoshuo.ren",
    "items": [
        {
            "id": "https://blog.baoshuo.ren/post/segment-tree/",
            "url": "https://blog.baoshuo.ren/post/segment-tree/",
            "title": "线段树学习笔记",
            "date_published": "2020-12-02T00:08:39.000Z",
            "content_html": "<p>线段树（Segment Tree）是一种用来维护区间的数据结构。</p>\n<a id=\"more\"></a>\n<p>与树状数组相比，线段树可以实现时间复杂度在 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(\\log n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span> 级别的区间修改，还可以同时支持多种操作（加、乘、最值等）。</p>\n<h2 id=\"操作列表\">操作列表</h2>\n<ul>\n<li>上传（pushup）</li>\n<li>建树（build）</li>\n<li>下放懒标记（pushdown）</li>\n<li>区间查询（query）</li>\n<li>区间修改（modify）</li>\n</ul>\n<h2 id=\"通用操作\">通用操作</h2>\n<h3 id=\"存储线段树\">存储线段树</h3>\n<p>线段树是一个典型的二叉树，因此我们可以使用一个数组来存储线段树。</p>\n<p>分析：很容易就知道线段树的深度为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">⌈</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy=\"false\">⌉</mo></mrow><annotation encoding=\"application/x-tex\">\\lceil\\log n\\rceil</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">⌈</span><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">⌉</span></span></span></span> ，可得线段树的节点个数为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mrow><mrow><mo fence=\"true\">⌈</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo fence=\"true\">⌉</mo></mrow><mo>+</mo><mn>1</mn></mrow></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">2^{\\left\\lceil\\log{n}\\right\\rceil+1}-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9713299999999999em;vertical-align:-0.08333em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8879999999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"minner mtight\"><span class=\"mopen mtight delimcenter\" style=\"top:0em;\"><span class=\"mtight\">⌈</span></span><span class=\"mop mtight\"><span class=\"mtight\">l</span><span class=\"mtight\">o</span><span class=\"mtight\" style=\"margin-right:0.01389em;\">g</span></span><span class=\"mspace mtight\" style=\"margin-right:0.19516666666666668em;\"></span><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span><span class=\"mclose mtight delimcenter\" style=\"top:0em;\"><span class=\"mtight\">⌉</span></span></span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span>，粗略估计开大小为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>4</mn><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">4n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">4</span><span class=\"mord mathnormal\">n</span></span></span></span> 的数组即可（可以使用位运算写成 <code>n &lt;&lt; 2</code>）。</p>\n<pre><code class=\"highlight cpp\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span> &#123;</span>\n    <span class=\"keyword\">int</span> l, r;\n    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> s, d;\n\n    node() &#123;\n        l = r = s = d = <span class=\"number\">0</span>;\n    &#125;\n    node(<span class=\"keyword\">int</span> _l, <span class=\"keyword\">int</span> _r) &#123;\n        l = _l;\n        r = _r;\n        s = d = <span class=\"number\">0</span>;\n    &#125;\n&#125; tr[<span class=\"number\">100005</span> &lt;&lt; <span class=\"number\">2</span>];</code></pre>\n<table>\n<thead>\n<tr>\n<th>变量名</th>\n<th>用途</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>l</td>\n<td>区间的左端点</td>\n</tr>\n<tr>\n<td>r</td>\n<td>区间的右端点</td>\n</tr>\n<tr>\n<td>s</td>\n<td>区间和</td>\n</tr>\n<tr>\n<td>d</td>\n<td>懒标记</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"上传（pushup）\">上传（pushup）</h3>\n<p>之所以把上传放在建树前面说，是因为建树的时候要用到它。</p>\n<pre><code class=\"highlight cpp\"><span class=\"comment\">/**</span>\n<span class=\"comment\"> * 上传信息</span>\n<span class=\"comment\"> * @param u 父节点下标</span>\n<span class=\"comment\"> */</span>\n<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">pushup</span><span class=\"params\">(<span class=\"keyword\">int</span> u)</span> </span>&#123;\n    tr[u].s = tr[u &lt;&lt; <span class=\"number\">1</span>].s + tr[u &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].s;\n&#125;</code></pre>\n<p>将两个子节点所代表的区间的和相加即为父区间的和。</p>\n<h3 id=\"建树（build）\">建树（build）</h3>\n<pre><code class=\"highlight cpp\"><span class=\"comment\">/**</span>\n<span class=\"comment\"> * 建立线段树</span>\n<span class=\"comment\"> * @param u 根节点下标</span>\n<span class=\"comment\"> * @param l 左端点</span>\n<span class=\"comment\"> * @param r 右端点</span>\n<span class=\"comment\"> */</span>\n<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"keyword\">int</span> u, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span> </span>&#123;\n    tr[u] = node(l, r);\n    <span class=\"keyword\">if</span> (l == r) &#123;\n        tr[u].s = a[l];\n        <span class=\"keyword\">return</span>;\n    &#125;\n    <span class=\"keyword\">int</span> mid = l + r &gt;&gt; <span class=\"number\">1</span>;\n    build(u &lt;&lt; <span class=\"number\">1</span>, l, mid);\n    build(u &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, mid + <span class=\"number\">1</span>, r);\n    pushup(u);\n&#125;</code></pre>\n<p>先初始化当前区间，接下来分两种情况：</p>\n<ol>\n<li>若当前区间长度等于 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn><mtext>  </mtext><mo stretchy=\"false\">(</mo><mi>l</mi><mo>=</mo><mi>r</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">1\\ \\ (l = r)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mspace\"> </span><span class=\"mspace\"> </span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mclose\">)</span></span></span></span> ，则直接将当前区间的区间和赋值为 <code>a[l]</code> 即可。</li>\n<li>若当前区间长度大于 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn><mtext>  </mtext><mo stretchy=\"false\">(</mo><mi>l</mi><mo>&lt;</mo><mi>r</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">1\\ \\ (l &lt; r)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mspace\"> </span><span class=\"mspace\"> </span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mclose\">)</span></span></span></span> ，则将区间平均分成两部分（即从 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">⌊</mo><mo stretchy=\"false\">(</mo><mi>l</mi><mo>+</mo><mi>r</mi><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">/</mi><mn>2</mn><mo stretchy=\"false\">⌋</mo></mrow><annotation encoding=\"application/x-tex\">\\lfloor(l+r)/2\\rfloor</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">⌊</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mclose\">)</span><span class=\"mord\">/</span><span class=\"mord\">2</span><span class=\"mclose\">⌋</span></span></span></span> 处断开分为两个区间，可写作 <code>l + r &gt;&gt; 1</code>），继续向下递归建立左右子树即可。</li>\n</ol>\n<p>需要注意的是两个子区间没有交集，因此左子树的左端点是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>l</mi></mrow><annotation encoding=\"application/x-tex\">l</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span></span></span></span> 、右端点是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi><mi>i</mi><mi>d</mi></mrow><annotation encoding=\"application/x-tex\">mid</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">d</span></span></span></span> ，右子树的左端点是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi><mi>i</mi><mi>d</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">mid+1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.77777em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">d</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 、右端点是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>r</mi></mrow><annotation encoding=\"application/x-tex\">r</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span></span></span></span> 。</p>\n<h3 id=\"区间查询（query）\">区间查询（query）</h3>\n<pre><code class=\"highlight cpp\"><span class=\"comment\">/**</span>\n<span class=\"comment\"> * 区间查询</span>\n<span class=\"comment\"> * @param u 父节点</span>\n<span class=\"comment\"> * @param l 左端点</span>\n<span class=\"comment\"> * @param r 右端点</span>\n<span class=\"comment\"> */</span>\n<span class=\"function\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">int</span> u, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span> </span>&#123;\n    <span class=\"keyword\">if</span> (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) &#123;  <span class=\"comment\">// 被包含直接返回当前区间和</span>\n        <span class=\"keyword\">return</span> tr[u].s;\n    &#125;\n    <span class=\"keyword\">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class=\"number\">1</span>;\n    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> s = <span class=\"number\">0</span>;\n    pushdown(u);                                <span class=\"comment\">// 下放懒标记</span>\n    <span class=\"keyword\">if</span> (l &lt;= mid) s += query(u &lt;&lt; <span class=\"number\">1</span>, l, r);     <span class=\"comment\">// 和左侧有交集</span>\n    <span class=\"keyword\">if</span> (r &gt; mid) s += query(u &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, l, r);  <span class=\"comment\">// 和右侧有交集</span>\n    <span class=\"keyword\">return</span> s;\n&#125;</code></pre>\n<ol>\n<li>如果这个区间被包含，直接返回该区间的和。</li>\n<li>如果和左儿子区间有交集，则继续向左儿子区间递归查询。</li>\n<li>如果和右儿子区间有交集，则继续向右儿子区间递归查询。</li>\n</ol>\n<p>需要注意的是在递归查询左右儿子区间之前要先下放懒标记（pushdown），否则会出问题。</p>\n<h2 id=\"区间加\">区间加</h2>\n<p>本部分以 <a href=\"https://www.luogu.com.cn/problem/P3372\">洛谷 P3372 【模板】线段树 1</a> 为例子来简述一下线段树区间加的实现。</p>\n<h3 id=\"下放懒标记（pushdown）\">下放懒标记（pushdown）</h3>\n<pre><code class=\"highlight cpp\"><span class=\"comment\">/**</span>\n<span class=\"comment\"> * 下放懒标记</span>\n<span class=\"comment\"> * @param u 父节点下标</span>\n<span class=\"comment\"> */</span>\n<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">pushdown</span><span class=\"params\">(<span class=\"keyword\">int</span> u)</span> </span>&#123;\n    <span class=\"keyword\">if</span> (!tr[u].d) <span class=\"keyword\">return</span>;\n    <span class=\"comment\">// 处理左子树</span>\n    tr[u &lt;&lt; <span class=\"number\">1</span>].d += tr[u].d;\n    tr[u &lt;&lt; <span class=\"number\">1</span>].s += (tr[u &lt;&lt; <span class=\"number\">1</span>].r - tr[u &lt;&lt; <span class=\"number\">1</span>].l + <span class=\"number\">1</span>) * tr[u].d;\n    <span class=\"comment\">// 处理右子树</span>\n    tr[u &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].d += tr[u].d;\n    tr[u &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].s += (tr[u &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].r - tr[u &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].l + <span class=\"number\">1</span>) * tr[u].d;\n    <span class=\"comment\">// 清除懒标记</span>\n    tr[u].d = <span class=\"number\">0</span>;\n&#125;</code></pre>\n<p>这部分代码其实很简单。</p>\n<p>将左、右子树的懒标记加上父节点的懒标记，区间和加上 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>r</mi><mo>−</mo><mi>l</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo>×</mo><mi>d</mi></mrow><annotation encoding=\"application/x-tex\">(r - l + 1)\\times d</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.77777em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">d</span></span></span></span> （<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>r</mi><mo separator=\"true\">,</mo><mi>l</mi></mrow><annotation encoding=\"application/x-tex\">r, l</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span></span></span></span> 分别表示儿子区间的左、右端点，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>d</mi></mrow><annotation encoding=\"application/x-tex\">d</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">d</span></span></span></span>表示父节点的懒标记），最后清空父节点的懒标记即可。</p>\n<h3 id=\"区间修改（modify）\">区间修改（modify）</h3>\n<pre><code class=\"highlight cpp\"><span class=\"comment\">/**</span>\n<span class=\"comment\"> * 区间修改</span>\n<span class=\"comment\"> * @param u 父节点下标</span>\n<span class=\"comment\"> * @param l 左端点</span>\n<span class=\"comment\"> * @param r 右端点</span>\n<span class=\"comment\"> * @param d 增加的值</span>\n<span class=\"comment\"> */</span>\n<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">modify</span><span class=\"params\">(<span class=\"keyword\">int</span> u, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> d)</span> </span>&#123;\n    <span class=\"keyword\">if</span> (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) &#123;  <span class=\"comment\">// 被包含直接修改</span>\n        tr[u].d += d;\n        tr[u].s += (tr[u].r - tr[u].l + <span class=\"number\">1</span>) * d;\n        <span class=\"keyword\">return</span>;\n    &#125;\n    <span class=\"keyword\">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class=\"number\">1</span>;\n    pushdown(u);                               <span class=\"comment\">// 下放懒标记</span>\n    <span class=\"keyword\">if</span> (l &lt;= mid) modify(u &lt;&lt; <span class=\"number\">1</span>, l, r, d);     <span class=\"comment\">// 和左侧有交集</span>\n    <span class=\"keyword\">if</span> (r &gt; mid) modify(u &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, l, r, d);  <span class=\"comment\">// 和右侧有交集</span>\n    pushup(u);                                 <span class=\"comment\">// 上传新信息</span>\n&#125;</code></pre>\n<p>区间修改和区间查询的实现相似。</p>\n<ol>\n<li>如果当前区间被包含，直接添加懒标记并修改区间和。</li>\n<li>如果和左儿子区间有交集，则继续向左儿子区间递归修改。</li>\n<li>如果和右儿子区间有交集，则继续向右儿子区间递归修改。</li>\n</ol>\n<p>需要注意的是在递归修改左右儿子区间之前要先下放懒标记（pushdown），修改完成以后要上传新信息（pushup），否则会出问题。</p>\n<h2 id=\"区间加、乘\">区间加、乘</h2>\n<p>本部分以 <a href=\"https://www.luogu.com.cn/problem/P3373\">洛谷 P3373 【模板】线段树 2</a> 为例子来简述一下线段树区间加、乘的实现。</p>\n<p>在编写之前，结构体中需要先添加一个乘法的懒标记 <code>x</code> ，并将其赋初值为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> ，修改之后的结构体如下所示。</p>\n<pre><code class=\"highlight cpp\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span> &#123;</span>\n    <span class=\"keyword\">int</span> l, r;\n    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> s, d, x;\n\n    node() &#123;\n        l = r = s = d = <span class=\"number\">0</span>;\n        x = <span class=\"number\">1</span>;\n    &#125;\n    node(<span class=\"keyword\">int</span> _l, <span class=\"keyword\">int</span> _r) &#123;\n        l = _l, r = _r;\n        s = d = <span class=\"number\">0</span>;\n        x = <span class=\"number\">1</span>;\n    &#125;\n&#125; tr[<span class=\"number\">100005</span> &lt;&lt; <span class=\"number\">2</span>];</code></pre>\n<h3 id=\"下放懒标记（pushdown）-2\">下放懒标记（pushdown）</h3>\n<pre><code class=\"highlight cpp\"><span class=\"comment\">/**</span>\n<span class=\"comment\"> * 下放懒标记</span>\n<span class=\"comment\"> * @param u 父节点下标</span>\n<span class=\"comment\"> * @attention 先乘后加</span>\n<span class=\"comment\"> */</span>\n<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">pushdown</span><span class=\"params\">(<span class=\"keyword\">int</span> u)</span> </span>&#123;\n    <span class=\"comment\">// 左子树</span>\n    tr[u &lt;&lt; <span class=\"number\">1</span>].s = ((tr[u &lt;&lt; <span class=\"number\">1</span>].s * tr[u].x) + (tr[u &lt;&lt; <span class=\"number\">1</span>].r - tr[u &lt;&lt; <span class=\"number\">1</span>].l + <span class=\"number\">1</span>) * tr[u].d) % p;\n    tr[u &lt;&lt; <span class=\"number\">1</span>].x = tr[u &lt;&lt; <span class=\"number\">1</span>].x * tr[u].x % p;\n    tr[u &lt;&lt; <span class=\"number\">1</span>].d = (tr[u &lt;&lt; <span class=\"number\">1</span>].d * tr[u].x + tr[u].d) % p;\n    <span class=\"comment\">// 右子树</span>\n    tr[u &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].s = ((tr[u &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].s * tr[u].x) + (tr[u &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].r - tr[u &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].l + <span class=\"number\">1</span>) * tr[u].d) % p;\n    tr[u &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].x = tr[u &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].x * tr[u].x % p;\n    tr[u &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].d = (tr[u &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].d * tr[u].x + tr[u].d) % p;\n    <span class=\"comment\">// 清除懒标记</span>\n    tr[u].d = <span class=\"number\">0</span>;\n    tr[u].x = <span class=\"number\">1</span>;\n&#125;</code></pre>\n<p>此处遵循<strong>先乘后加</strong>的原则，先修改区间和，再修改乘法懒标记，最后修改加法懒标记，不要忘记 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext> </mtext><mo lspace=\"0.22em\" rspace=\"0.22em\"><mrow><mi mathvariant=\"normal\">m</mi><mi mathvariant=\"normal\">o</mi><mi mathvariant=\"normal\">d</mi></mrow></mo><mtext> </mtext><mtext> </mtext><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">\\bmod\\ p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mspace\" style=\"margin-right:0.05555555555555555em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathrm\">m</span><span class=\"mord mathrm\">o</span><span class=\"mord mathrm\">d</span></span></span><span class=\"mspace\" style=\"margin-right:0.05555555555555555em;\"></span><span class=\"mspace\"> </span><span class=\"mord mathnormal\">p</span></span></span></span>。</p>\n<p>注意：此处清除懒标记的时候，乘法懒标记应修改为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 。</p>\n<h3 id=\"区间修改（modify）-2\">区间修改（modify）</h3>\n<pre><code class=\"highlight cpp\"><span class=\"comment\">/**</span>\n<span class=\"comment\"> * 区间修改</span>\n<span class=\"comment\"> * @details 修改区间 [l, r] 中的每一个数</span>\n<span class=\"comment\"> * @param u 父节点下标</span>\n<span class=\"comment\"> * @param l 左端点</span>\n<span class=\"comment\"> * @param r 右端点</span>\n<span class=\"comment\"> * @param x 乘上的数</span>\n<span class=\"comment\"> * @param d 增加的值</span>\n<span class=\"comment\"> */</span>\n<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">modify</span><span class=\"params\">(<span class=\"keyword\">int</span> u, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> x, <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> d)</span> </span>&#123;\n    <span class=\"comment\">// 被包含直接修改</span>\n    <span class=\"keyword\">if</span> (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) &#123;\n        tr[u].s = ((tr[u].s * x) + (tr[u].r - tr[u].l + <span class=\"number\">1</span>) * d) % p;\n        tr[u].x = tr[u].x * x % p;\n        tr[u].d = (tr[u].d * x + d) % p;\n        <span class=\"keyword\">return</span>;\n    &#125;\n    <span class=\"keyword\">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class=\"number\">1</span>;\n    pushdown(u);                                  <span class=\"comment\">// 下放懒标记</span>\n    <span class=\"keyword\">if</span> (l &lt;= mid) modify(u &lt;&lt; <span class=\"number\">1</span>, l, r, x, d);     <span class=\"comment\">// 和左侧有交集</span>\n    <span class=\"keyword\">if</span> (r &gt; mid) modify(u &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, l, r, x, d);  <span class=\"comment\">// 和右侧有交集</span>\n    pushup(u);                                    <span class=\"comment\">// 上传新信息</span>\n&#125;</code></pre>\n<p>大体上和加法的修改函数一样，而在修改时与下放懒标记做法相同，遵循<strong>先乘后加</strong>的原则。</p>\n<p>调用的时候若只需要使用乘法部分，加数设置为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span> 即可。若只需要使用加法部分，乘数设置为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 即可。</p>\n<h2 id=\"全部代码\">全部代码</h2>\n<p>到这里基本操作就说完了，下面是全部的 AC 代码。</p>\n<h3 id=\"区间加-2\">区间加</h3>\n<pre><code class=\"highlight cpp\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span>\n\n<span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;\n\n<span class=\"comment\">/**</span>\n<span class=\"comment\"> * 线段树节点</span>\n<span class=\"comment\"> */</span>\n<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span> &#123;</span>\n    <span class=\"keyword\">int</span> l, r;\n    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> s, d;\n\n    node() &#123;\n        l = r = s = d = <span class=\"number\">0</span>;\n    &#125;\n    node(<span class=\"keyword\">int</span> _l, <span class=\"keyword\">int</span> _r) &#123;\n        l = _l;\n        r = _r;\n        s = d = <span class=\"number\">0</span>;\n    &#125;\n&#125; tr[<span class=\"number\">100005</span> &lt;&lt; <span class=\"number\">2</span>];\n<span class=\"keyword\">int</span> n, m, op, x, y, k, a[<span class=\"number\">100005</span>];\n\n<span class=\"comment\">/**</span>\n<span class=\"comment\"> * 上传区间和</span>\n<span class=\"comment\"> * @param u 父节点下标</span>\n<span class=\"comment\"> */</span>\n<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">pushup</span><span class=\"params\">(<span class=\"keyword\">int</span> u)</span> </span>&#123;\n    tr[u].s = tr[u &lt;&lt; <span class=\"number\">1</span>].s + tr[u &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].s;\n&#125;\n\n<span class=\"comment\">/**</span>\n<span class=\"comment\"> * 下放懒标记</span>\n<span class=\"comment\"> * @param u 父节点下标</span>\n<span class=\"comment\"> */</span>\n<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">pushdown</span><span class=\"params\">(<span class=\"keyword\">int</span> u)</span> </span>&#123;\n    <span class=\"keyword\">if</span> (!tr[u].d) <span class=\"keyword\">return</span>;\n    <span class=\"comment\">// 处理左子树</span>\n    tr[u &lt;&lt; <span class=\"number\">1</span>].d += tr[u].d;\n    tr[u &lt;&lt; <span class=\"number\">1</span>].s += (tr[u &lt;&lt; <span class=\"number\">1</span>].r - tr[u &lt;&lt; <span class=\"number\">1</span>].l + <span class=\"number\">1</span>) * tr[u].d;\n    <span class=\"comment\">// 处理右子树</span>\n    tr[u &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].d += tr[u].d;\n    tr[u &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].s += (tr[u &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].r - tr[u &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].l + <span class=\"number\">1</span>) * tr[u].d;\n    <span class=\"comment\">// 清除懒标记</span>\n    tr[u].d = <span class=\"number\">0</span>;\n&#125;\n\n<span class=\"comment\">/**</span>\n<span class=\"comment\"> * 建立线段树</span>\n<span class=\"comment\"> * @param u 根节点下标</span>\n<span class=\"comment\"> * @param l 左端点</span>\n<span class=\"comment\"> * @param r 右端点</span>\n<span class=\"comment\"> */</span>\n<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"keyword\">int</span> u, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span> </span>&#123;\n    tr[u] = node(l, r);\n    <span class=\"keyword\">if</span> (l == r) &#123;\n        tr[u].s = a[l];\n        <span class=\"keyword\">return</span>;\n    &#125;\n    <span class=\"keyword\">int</span> mid = l + r &gt;&gt; <span class=\"number\">1</span>;\n    build(u &lt;&lt; <span class=\"number\">1</span>, l, mid);\n    build(u &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, mid + <span class=\"number\">1</span>, r);\n    pushup(u);\n&#125;\n\n<span class=\"comment\">/**</span>\n<span class=\"comment\"> * 区间修改</span>\n<span class=\"comment\"> * @param u 父节点下标</span>\n<span class=\"comment\"> * @param l 左端点</span>\n<span class=\"comment\"> * @param r 右端点</span>\n<span class=\"comment\"> * @param d 增加的值</span>\n<span class=\"comment\"> */</span>\n<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">modify</span><span class=\"params\">(<span class=\"keyword\">int</span> u, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> d)</span> </span>&#123;\n    <span class=\"keyword\">if</span> (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) &#123;  <span class=\"comment\">// 被包含直接修改</span>\n        tr[u].d += d;\n        tr[u].s += (tr[u].r - tr[u].l + <span class=\"number\">1</span>) * d;\n        <span class=\"keyword\">return</span>;\n    &#125;\n    <span class=\"keyword\">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class=\"number\">1</span>;\n    pushdown(u);                               <span class=\"comment\">// 下放懒标记</span>\n    <span class=\"keyword\">if</span> (l &lt;= mid) modify(u &lt;&lt; <span class=\"number\">1</span>, l, r, d);     <span class=\"comment\">// 和左侧有交集</span>\n    <span class=\"keyword\">if</span> (r &gt; mid) modify(u &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, l, r, d);  <span class=\"comment\">// 和右侧有交集</span>\n    pushup(u);                                 <span class=\"comment\">// 上传新信息</span>\n&#125;\n\n<span class=\"comment\">/**</span>\n<span class=\"comment\"> * 区间查询</span>\n<span class=\"comment\"> * @param u 父节点</span>\n<span class=\"comment\"> * @param l 左端点</span>\n<span class=\"comment\"> * @param r 右端点</span>\n<span class=\"comment\"> */</span>\n<span class=\"function\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">int</span> u, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span> </span>&#123;\n    <span class=\"keyword\">if</span> (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) &#123;  <span class=\"comment\">// 被包含直接返回</span>\n        <span class=\"keyword\">return</span> tr[u].s;\n    &#125;\n    <span class=\"keyword\">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class=\"number\">1</span>;\n    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> s = <span class=\"number\">0</span>;\n    pushdown(u);                                <span class=\"comment\">// 下放懒标记</span>\n    <span class=\"keyword\">if</span> (l &lt;= mid) s += query(u &lt;&lt; <span class=\"number\">1</span>, l, r);     <span class=\"comment\">// 和左侧有交集</span>\n    <span class=\"keyword\">if</span> (r &gt; mid) s += query(u &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, l, r);  <span class=\"comment\">// 和右侧有交集</span>\n    <span class=\"keyword\">return</span> s;\n&#125;\n\n<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;\n    <span class=\"built_in\">cin</span> &gt;&gt; n &gt;&gt; m;\n    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;\n        <span class=\"built_in\">cin</span> &gt;&gt; a[i];\n    &#125;\n    build(<span class=\"number\">1</span>, <span class=\"number\">1</span>, n);\n    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++) &#123;\n        <span class=\"built_in\">cin</span> &gt;&gt; op &gt;&gt; x &gt;&gt; y;\n        <span class=\"keyword\">if</span> (op == <span class=\"number\">1</span>) &#123;\n            <span class=\"built_in\">cin</span> &gt;&gt; k;\n            modify(<span class=\"number\">1</span>, x, y, k);\n        &#125;\n        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (op == <span class=\"number\">2</span>) &#123;\n            <span class=\"built_in\">cout</span> &lt;&lt; query(<span class=\"number\">1</span>, x, y) &lt;&lt; <span class=\"built_in\">endl</span>;\n        &#125;\n    &#125;\n    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;\n&#125;</code></pre>\n<h3 id=\"区间加、乘-2\">区间加、乘</h3>\n<pre><code class=\"highlight cpp\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span>\n\n<span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;\n\n<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span> &#123;</span>\n    <span class=\"keyword\">int</span> l, r;\n    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> s, d, x;\n\n    node() &#123;\n        l = r = s = d = <span class=\"number\">0</span>;\n        x = <span class=\"number\">1</span>;\n    &#125;\n    node(<span class=\"keyword\">int</span> _l, <span class=\"keyword\">int</span> _r) &#123;\n        l = _l, r = _r;\n        s = d = <span class=\"number\">0</span>;\n        x = <span class=\"number\">1</span>;\n    &#125;\n&#125; tr[<span class=\"number\">100005</span> &lt;&lt; <span class=\"number\">2</span>];\n<span class=\"keyword\">int</span> n, m, p, op, x, y;\n<span class=\"keyword\">long</span> <span class=\"keyword\">long</span> k, a[<span class=\"number\">100005</span>];\n\n<span class=\"comment\">/**</span>\n<span class=\"comment\"> * 上传信息</span>\n<span class=\"comment\"> * @param u 父节点下标</span>\n<span class=\"comment\"> */</span>\n<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">pushup</span><span class=\"params\">(<span class=\"keyword\">int</span> u)</span> </span>&#123;\n    tr[u].s = (tr[u &lt;&lt; <span class=\"number\">1</span>].s + tr[u &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].s) % p;\n&#125;\n\n<span class=\"comment\">/**</span>\n<span class=\"comment\"> * 下放懒标记</span>\n<span class=\"comment\"> * @param u 父节点下标</span>\n<span class=\"comment\"> * @attention 先乘后加</span>\n<span class=\"comment\"> */</span>\n<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">pushdown</span><span class=\"params\">(<span class=\"keyword\">int</span> u)</span> </span>&#123;\n    <span class=\"comment\">// 左子树</span>\n    tr[u &lt;&lt; <span class=\"number\">1</span>].s = ((tr[u &lt;&lt; <span class=\"number\">1</span>].s * tr[u].x) + (tr[u &lt;&lt; <span class=\"number\">1</span>].r - tr[u &lt;&lt; <span class=\"number\">1</span>].l + <span class=\"number\">1</span>) * tr[u].d) % p;\n    tr[u &lt;&lt; <span class=\"number\">1</span>].x = tr[u &lt;&lt; <span class=\"number\">1</span>].x * tr[u].x % p;\n    tr[u &lt;&lt; <span class=\"number\">1</span>].d = (tr[u &lt;&lt; <span class=\"number\">1</span>].d * tr[u].x + tr[u].d) % p;\n    <span class=\"comment\">// 右子树</span>\n    tr[u &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].s = ((tr[u &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].s * tr[u].x) + (tr[u &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].r - tr[u &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].l + <span class=\"number\">1</span>) * tr[u].d) % p;\n    tr[u &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].x = tr[u &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].x * tr[u].x % p;\n    tr[u &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].d = (tr[u &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].d * tr[u].x + tr[u].d) % p;\n    <span class=\"comment\">// 清除懒标记</span>\n    tr[u].d = <span class=\"number\">0</span>;\n    tr[u].x = <span class=\"number\">1</span>;\n&#125;\n\n<span class=\"comment\">/**</span>\n<span class=\"comment\"> * 建立线段树</span>\n<span class=\"comment\"> * @param u 根节点下标</span>\n<span class=\"comment\"> * @param l 左端点</span>\n<span class=\"comment\"> * @param r 右端点</span>\n<span class=\"comment\"> */</span>\n<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"keyword\">int</span> u, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span> </span>&#123;\n    tr[u] = node(l, r);\n    <span class=\"keyword\">if</span> (l == r) &#123;\n        tr[u].s = a[l] % p;\n        <span class=\"keyword\">return</span>;\n    &#125;\n    <span class=\"keyword\">int</span> mid = l + r &gt;&gt; <span class=\"number\">1</span>;\n    build(u &lt;&lt; <span class=\"number\">1</span>, l, mid);\n    build(u &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, mid + <span class=\"number\">1</span>, r);\n    pushup(u);\n&#125;\n\n<span class=\"comment\">/**</span>\n<span class=\"comment\"> * 区间修改</span>\n<span class=\"comment\"> * @details 将区间 [l, r] 中的每一个数加上 d</span>\n<span class=\"comment\"> * @param u 父节点下标</span>\n<span class=\"comment\"> * @param l 左端点</span>\n<span class=\"comment\"> * @param r 右端点</span>\n<span class=\"comment\"> * @param x 乘上的数</span>\n<span class=\"comment\"> * @param d 增加的值</span>\n<span class=\"comment\"> */</span>\n<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">modify</span><span class=\"params\">(<span class=\"keyword\">int</span> u, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> x, <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> d)</span> </span>&#123;\n    <span class=\"comment\">// 被包含直接修改</span>\n    <span class=\"keyword\">if</span> (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) &#123;\n        tr[u].s = ((tr[u].s * x) + (tr[u].r - tr[u].l + <span class=\"number\">1</span>) * d) % p;\n        tr[u].x = tr[u].x * x % p;\n        tr[u].d = (tr[u].d * x + d) % p;\n        <span class=\"keyword\">return</span>;\n    &#125;\n    <span class=\"keyword\">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class=\"number\">1</span>;\n    pushdown(u);                                  <span class=\"comment\">// 下放懒标记</span>\n    <span class=\"keyword\">if</span> (l &lt;= mid) modify(u &lt;&lt; <span class=\"number\">1</span>, l, r, x, d);     <span class=\"comment\">// 和左侧有交集</span>\n    <span class=\"keyword\">if</span> (r &gt; mid) modify(u &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, l, r, x, d);  <span class=\"comment\">// 和右侧有交集</span>\n    pushup(u);                                    <span class=\"comment\">// 上传新信息</span>\n&#125;\n\n<span class=\"comment\">/**</span>\n<span class=\"comment\"> * 区间查询</span>\n<span class=\"comment\"> * @param u </span>\n<span class=\"comment\"> * @param l </span>\n<span class=\"comment\"> * @param r </span>\n<span class=\"comment\"> * @return int </span>\n<span class=\"comment\"> */</span>\n<span class=\"function\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">int</span> u, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span> </span>&#123;\n    <span class=\"keyword\">if</span> (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) &#123;  <span class=\"comment\">// 被包含直接返回</span>\n        <span class=\"keyword\">return</span> tr[u].s;\n    &#125;\n    <span class=\"keyword\">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class=\"number\">1</span>;\n    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> s = <span class=\"number\">0</span>;\n    pushdown(u);                                         <span class=\"comment\">// 下放懒标记</span>\n    <span class=\"keyword\">if</span> (l &lt;= mid) s = query(u &lt;&lt; <span class=\"number\">1</span>, l, r);               <span class=\"comment\">// 和左侧有交集</span>\n    <span class=\"keyword\">if</span> (r &gt; mid) s = (s + query(u &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, l, r)) % p;  <span class=\"comment\">// 和右侧有交集</span>\n    <span class=\"keyword\">return</span> s;\n&#125;\n\n<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;\n    <span class=\"built_in\">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; p;\n    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;\n        <span class=\"built_in\">cin</span> &gt;&gt; a[i];\n    &#125;\n    build(<span class=\"number\">1</span>, <span class=\"number\">1</span>, n);\n    <span class=\"keyword\">while</span> (m--) &#123;\n        <span class=\"built_in\">cin</span> &gt;&gt; op &gt;&gt; x &gt;&gt; y;\n        <span class=\"keyword\">if</span> (op == <span class=\"number\">1</span>) &#123;\n            <span class=\"built_in\">cin</span> &gt;&gt; k;\n            modify(<span class=\"number\">1</span>, x, y, k, <span class=\"number\">0</span>);\n        &#125;\n        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (op == <span class=\"number\">2</span>) &#123;\n            <span class=\"built_in\">cin</span> &gt;&gt; k;\n            modify(<span class=\"number\">1</span>, x, y, <span class=\"number\">1</span>, k);\n        &#125;\n        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (op == <span class=\"number\">3</span>) &#123;\n            <span class=\"built_in\">cout</span> &lt;&lt; query(<span class=\"number\">1</span>, x, y) % p &lt;&lt; <span class=\"built_in\">endl</span>;\n        &#125;\n    &#125;\n    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;\n&#125;</code></pre>",
            "tags": [
                "笔记"
            ]
        }
    ]
}