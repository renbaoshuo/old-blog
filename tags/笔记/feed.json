{
    "version": "https://jsonfeed.org/version/1",
    "title": "宝硕博客 • All posts by \"笔记\" tag",
    "description": "宝硕博客 —— Baoshuo (@renbaoshuo) 随便写东西的地方，以技术向博文为主，生活向博文为辅。",
    "home_page_url": "https://blog.baoshuo.ren",
    "items": [
        {
            "id": "https://blog.baoshuo.ren/post/graph-shortest-path/",
            "url": "https://blog.baoshuo.ren/post/graph-shortest-path/",
            "title": "最短路学习笔记",
            "date_published": "2021-08-12T02:50:06.000Z",
            "content_html": "<p>最短路径问题是图论研究中的一个经典算法问题，旨在寻找图（由节点和路径组成的）中两节点之间的最短路径。</p>\n<a id=\"more\"></a>\n<p>由于竞赛中不考查文中所述算法的证明，故本文不探讨与证明相关的内容，如有需要请自行查阅维基百科。</p>\n<h2 id=\"性质\">性质</h2>\n<ol>\n<li>对于边权为正的图，任意两个节点间的最短路不会重复经过某一个点或某一条边。</li>\n<li>对于边权为正的图，任意两个节点间的最短路中的任意一条的节点数不会超过 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> ，边数不会超过 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">n - 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 。</li>\n</ol>\n<h2 id=\"确定起点的最短路径问题\">确定起点的最短路径问题</h2>\n<p>这种问题也叫单源最短路问题，即已知起始节点，求最短路径的问题。在边权非负时适合使用 Dijkstra 算法，若边权为负时则适合使用 Bellman-ford 算法或者 SPFA 算法。</p>\n<h3 id=\"Dijkstra-算法\">Dijkstra 算法</h3>\n<p>该算法的时间复杂度为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> ，使用<a href=\"#%E5%A0%86%E4%BC%98%E5%8C%96%E7%9A%84-Dijkstra-%E7%AE%97%E6%B3%95\">堆优化</a>后可达 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>m</mi><mi>log</mi><mo>⁡</mo><mi>m</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(m \\log m)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mclose\">)</span></span></span></span> 。</p>\n<h4 id=\"演示\">演示</h4>\n<p><img src=\"https://vip2.loli.io/2021/07/19/Ppk3vdLbMyqKoEl.gif\" alt=\"Dijkstra 算法运行演示\" loading=\"lazy\" data-action=\"zoom\"><span class=\"image-description\">Dijkstra 算法运行演示</span></p>\n<p>Dijkstra 算法每次取出未访问节点中距离最小的节点，并用该节点更新其他节点的距离。（在演示过程中访问过的节点会被标为红色）</p>\n<h4 id=\"实现\">实现</h4>\n<ol>\n<li>定义一个名为 <code>dist</code> 的数组存储从起点到各点的距离，并将起点的值初始化为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span> 、其余点的距离初始化为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∞</mi></mrow><annotation encoding=\"application/x-tex\">\\infty</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord\">∞</span></span></span></span> 。<br>定义一个名为 <code>g</code> 的二维数组存图，将各点自己到自己的距离值初始化为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span> ，其余距离值初始化为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∞</mi></mrow><annotation encoding=\"application/x-tex\">\\infty</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord\">∞</span></span></span></span> 。<br>设集合 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span> 存储当前已确定最短路的点。</li>\n<li>遍历 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">n - 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 次，每次寻找一个不在 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span> 中的且距离起点最近的点，记为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>t</mi></mrow><annotation encoding=\"application/x-tex\">t</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.61508em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">t</span></span></span></span> ，并将 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>t</mi></mrow><annotation encoding=\"application/x-tex\">t</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.61508em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">t</span></span></span></span> 加入集合 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span> 。当从起点到某个点的距离比从起点经过 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>t</mi></mrow><annotation encoding=\"application/x-tex\">t</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.61508em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">t</span></span></span></span> 再到这个点的距离大时就更新从起点到这个点的距离，即 <code>dist[j] = min(dist[j], dist[t] + g[t][j])</code> 。</li>\n<li>最后 <code>dist</code> 数组里即为从起点到各点的最短距离。</li>\n</ol>\n<h4 id=\"代码\">代码</h4>\n<p>题目链接：<a href=\"https://www.acwing.com/problem/content/description/851/\">849. Dijkstra 求最短路 I - AcWing</a></p>\n<pre><code class=\"highlight cpp\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span>\n\n<span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;\n\n<span class=\"keyword\">int</span> n, m, x, y, z, g[<span class=\"number\">505</span>][<span class=\"number\">505</span>], dist[<span class=\"number\">505</span>];\n<span class=\"keyword\">bool</span> st[<span class=\"number\">505</span>];\n\n<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">diskstra</span><span class=\"params\">()</span> </span>&#123;\n    <span class=\"built_in\">memset</span>(dist, <span class=\"number\">0x3f</span>, <span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(dist));\n    dist[<span class=\"number\">1</span>] = <span class=\"number\">0</span>;\n    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; n; i++) &#123;\n        <span class=\"keyword\">int</span> t = <span class=\"number\">-1</span>;\n        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt;= n; j++) &#123;\n            <span class=\"keyword\">if</span> (!st[j] &amp;&amp; (t == <span class=\"number\">-1</span> || dist[t] &gt; dist[j])) &#123;\n                t = j;\n            &#125;\n        &#125;\n        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt;= n; j++) &#123;\n            dist[j] = <span class=\"built_in\">min</span>(dist[j], dist[t] + g[t][j]);\n        &#125;\n        st[t] = <span class=\"literal\">true</span>;\n    &#125;\n    <span class=\"keyword\">return</span> dist[n] == <span class=\"number\">0x3f3f3f3f</span> ? <span class=\"number\">-1</span> : dist[n];\n&#125;\n\n<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;\n    cin &gt;&gt; n &gt;&gt; m;\n    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;\n        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt;= n; j++) &#123;\n            g[i][j] = i == j ? <span class=\"number\">0</span> : <span class=\"number\">0x3f3f3f3f</span>;\n        &#125;\n    &#125;\n    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= m; i++) &#123;\n        cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;\n        g[x][y] = <span class=\"built_in\">min</span>(g[x][y], z);\n    &#125;\n    cout &lt;&lt; <span class=\"built_in\">diskstra</span>() &lt;&lt; endl;\n    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;\n&#125;</code></pre>\n<h3 id=\"堆优化的-Dijkstra-算法\">堆优化的 Dijkstra 算法</h3>\n<p>使用堆优化的 Dijkstra 算法的时间复杂度为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>m</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(m \\log n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></p>\n<h4 id=\"实现-2\">实现</h4>\n<p>使用堆代替找距离最近的点的操作即可。</p>\n<p>由于 C++ STL 中的优先队列不支持删除元素的操作，所以队列中会有重复元素导致复杂度变为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>m</mi><mi>log</mi><mo>⁡</mo><mi>m</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(m \\log m)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mclose\">)</span></span></span></span> ，但比手写堆要容易许多。</p>\n<h4 id=\"代码-2\">代码</h4>\n<p>题目链接：<a href=\"https://www.acwing.com/problem/content/description/852/\">850. Dijkstra 求最短路 II</a></p>\n<pre><code class=\"highlight cpp\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span>\n\n<span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;\n\n<span class=\"keyword\">int</span> n, m, u, v, w, dist[<span class=\"number\">200005</span>];\nvector&lt;pair&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt;&gt; g[<span class=\"number\">200005</span>];\n<span class=\"keyword\">bool</span> st[<span class=\"number\">200005</span>];\n\n<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dijkstra</span><span class=\"params\">()</span> </span>&#123;\n    <span class=\"built_in\">memset</span>(dist, <span class=\"number\">0x3f</span>, <span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(dist));\n    dist[<span class=\"number\">1</span>] = <span class=\"number\">0</span>;\n    priority_queue&lt;pair&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt;, vector&lt;pair&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt;&gt;, greater&lt;pair&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt;&gt;&gt; q;\n    q.<span class=\"built_in\">push</span>(<span class=\"built_in\">make_pair</span>(<span class=\"number\">0</span>, <span class=\"number\">1</span>));\n    <span class=\"keyword\">while</span> (!q.<span class=\"built_in\">empty</span>()) &#123;\n        <span class=\"keyword\">auto</span> t = q.<span class=\"built_in\">top</span>();\n        q.<span class=\"built_in\">pop</span>();\n        <span class=\"keyword\">if</span> (st[t.second]) <span class=\"keyword\">continue</span>;\n        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> i : g[t.second]) &#123;\n            <span class=\"keyword\">if</span> (dist[i.first] &gt; t.first + i.second) &#123;\n                dist[i.first] = t.first + i.second;\n                q.<span class=\"built_in\">push</span>(<span class=\"built_in\">make_pair</span>(dist[i.first], i.first));\n            &#125;\n        &#125;\n        st[tw] = <span class=\"literal\">true</span>;\n    &#125;\n&#125;\n\n<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;\n    cin &gt;&gt; n &gt;&gt; m;\n    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= m; i++) &#123;\n        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;\n        g[u].<span class=\"built_in\">push_back</span>(<span class=\"built_in\">make_pair</span>(v, w));\n    &#125;\n    <span class=\"built_in\">dijkstra</span>();\n    cout &lt;&lt; (dist[n] == <span class=\"number\">0x3f3f3f3f</span> ? <span class=\"number\">-1</span> : dist[n]) &lt;&lt; endl;\n    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;\n&#125;</code></pre>\n<h3 id=\"Bellman-Ford-算法\">Bellman-Ford 算法</h3>\n<p>该算法的时间复杂度为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mi>m</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(nm)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">m</span><span class=\"mclose\">)</span></span></span></span> （对于存在最短路的图）。</p>\n<h4 id=\"实现-3\">实现</h4>\n<ol>\n<li>定义一个名为 <code>dist</code> 的数组存储从起点到各点的距离，并将起点的值初始化为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span> 、其余点的距离初始化为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∞</mi></mrow><annotation encoding=\"application/x-tex\">\\infty</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord\">∞</span></span></span></span> 。</li>\n<li>遍历 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 次，并进行以下操作：\n<ol>\n<li>遍历所有边 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>u</mi><mo separator=\"true\">,</mo><mi>v</mi><mo separator=\"true\">,</mo><mi>w</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(u, v, w)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">u</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mclose\">)</span></span></span></span> ：若已有的从起点到 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi></mrow><annotation encoding=\"application/x-tex\">v</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span></span></span></span> 的路径长度大于从起点经过 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>u</mi><mo>→</mo><mi>v</mi></mrow><annotation encoding=\"application/x-tex\">u \\to v</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">u</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span></span></span></span> 这条边的路径长度，则更新最短路径长度。</li>\n</ol>\n</li>\n<li><code>dist</code> 数组即为所求。</li>\n</ol>\n<h4 id=\"判断负环\">判断负环</h4>\n<p>在第 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 次遍历后如果仍能更新最短路径长度则可以判断存在负环。</p>\n<h4 id=\"代码-3\">代码</h4>\n<pre><code class=\"highlight cpp\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span>\n\n<span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;\n\n<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span> &#123;</span>\n    <span class=\"keyword\">int</span> u, v, w;\n&#125; g[<span class=\"number\">10005</span>];\n\n<span class=\"keyword\">int</span> n, m, k, dist[<span class=\"number\">505</span>];\n\n<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">bellman_ford</span><span class=\"params\">()</span> </span>&#123;\n    <span class=\"built_in\">memset</span>(dist, <span class=\"number\">0x3f</span>, <span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(dist));\n    dist[<span class=\"number\">1</span>] = <span class=\"number\">0</span>;\n    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= k; i++) &#123;\n        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt;= m; j++) &#123;\n            dist[g[j].v] = <span class=\"built_in\">min</span>(dist[g[j].v], dist[g[j].u] + g[j].w);\n        &#125;\n    &#125;\n&#125;\n\n<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;\n    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= m; i++) &#123;\n        cin &gt;&gt; g[i].u &gt;&gt; g[i].v &gt;&gt; g[i].w;\n    &#125;\n    <span class=\"built_in\">bellman_ford</span>();\n    <span class=\"keyword\">if</span> (dist[n] &gt; <span class=\"number\">0x1f1f1f1f</span>) &#123;\n        cout &lt;&lt; <span class=\"string\">&quot;impossible&quot;</span> &lt;&lt; endl;\n    &#125; <span class=\"keyword\">else</span> &#123;\n        cout &lt;&lt; dist[n] &lt;&lt; endl;\n    &#125;\n    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;\n&#125;</code></pre>\n<h3 id=\"SPFA-算法\">SPFA 算法</h3>\n<p>SPFA 算法在国际上通称为「队列优化的 Bellman-Ford 算法」，时间复杂度一般情况下为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>m</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(m)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">m</span><span class=\"mclose\">)</span></span></span></span> ，最坏情况下为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mi>m</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(nm)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">m</span><span class=\"mclose\">)</span></span></span></span> 。</p>\n<h4 id=\"实现-4\">实现</h4>\n<ol>\n<li>先初始化一个队列，并将起点入队。</li>\n<li>一直循环直到队列为空：\n<ol>\n<li>取出队头，设其为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>t</mi></mrow><annotation encoding=\"application/x-tex\">t</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.61508em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">t</span></span></span></span> 并出队。</li>\n<li>如果 <code>dist[t]</code> 可以变小，则更新 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>t</mi></mrow><annotation encoding=\"application/x-tex\">t</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.61508em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">t</span></span></span></span> 的所有出边 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>t</mi><mover><mo stretchy=\"true\">→</mo><mpadded width=\"+0.6em\" lspace=\"0.3em\"><mi>w</mi></mpadded></mover><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">t \\xrightarrow{w} b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.934392em;vertical-align:-0.01100000000000001em;\"></span><span class=\"mord mathnormal\">t</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel x-arrow\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.923392em;\"><span style=\"top:-3.322em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight x-arrow-pad\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02691em;\">w</span></span></span></span><span class=\"svg-align\" style=\"top:-2.689em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"hide-tail\" style=\"height:0.522em;min-width:1.469em;\"><svg width='400em' height='0.522em' viewBox='0 0 400000 522' preserveAspectRatio='xMaxYMin slice'><path d='M0 241v40h399891c-47.3 35.3-84 78-110 128\n-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20\n 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7\n 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85\n-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5\n-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67\n 151.7 139 205zm0 0v40h399900v-40z'/></svg></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.01100000000000001em;\"><span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span> ，如果更新成功将 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span> 加入队列。</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"SPFA-判负环\">SPFA 判负环</h4>\n<p>在每次更新 <code>dist[x]</code> 的同时记录当前所走过的边数 <code>cnt[x] = cnt[t] + 1</code> ，若 <code>cnt[n]</code> 大于等于 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 则可以证明存在图中负环。</p>\n<p>由于从 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 号点开始走不能保证走到所有的负环，因此需要将节点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn><mo>∼</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">1 \\sim n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∼</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 都入队进行查找。</p>\n<h4 id=\"卡-SPFA\">卡 SPFA</h4>\n<ol>\n<li>生成一棵以起点为根的树，树高尽量高（比如 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 为起点时，可以令每个点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> 的父亲在 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>max</mi><mo>⁡</mo><mo stretchy=\"false\">(</mo><mi>i</mi><mo>−</mo><mn>5</mn><mo separator=\"true\">,</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\max(i - 5, 1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\">max</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">5</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span> 到 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">i - 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.74285em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 随机），边权随机，作为最短路径树，同时直接递推求出每个点的带权深度 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>d</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">d_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.84444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></li>\n<li>对于剩下的边，端点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>a</mi><mo separator=\"true\">,</mo><mi>b</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(a, b)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mclose\">)</span></span></span></span> 随机，边权在 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∣</mi><msub><mi>d</mi><mi>b</mi></msub><mo>−</mo><msub><mi>d</mi><mi>a</mi></msub><mi mathvariant=\"normal\">∣</mi></mrow><annotation encoding=\"application/x-tex\">|d_b - d_a|</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.33610799999999996em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">b</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">a</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord\">∣</span></span></span></span> 到 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∣</mi><msub><mi>d</mi><mi>b</mi></msub><mo>−</mo><msub><mi>d</mi><mi>a</mi></msub><mi mathvariant=\"normal\">∣</mi><mo>+</mo><mn>5</mn></mrow><annotation encoding=\"application/x-tex\">|d_b - d_a| + 5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.33610799999999996em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">b</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">a</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord\">∣</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">5</span></span></span></span> 随机（如果是有向图则去掉绝对值符号， <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>5</mn></mrow><annotation encoding=\"application/x-tex\">5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">5</span></span></span></span> 可以换成其他较小的正数）</li>\n</ol>\n<p>这样生成的图中，次短路的条数非常的多，而 SPFA 一旦错误地进入了次短路的分支，就会使得一整棵子树被赋错误的距离，从而在后期不得不重新更新。而由于边权接近，剪枝的效果会受到很大影响。</p>\n<h4 id=\"代码-4\">代码</h4>\n<p><strong>SPFA 求最短路</strong></p>\n<p>题目：<a href=\"https://www.acwing.com/problem/content/853/\">851. spfa求最短路 - AcWing</a></p>\n<pre><code class=\"highlight cpp\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span>\n\n<span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;\n\n<span class=\"keyword\">int</span> n, m, u, v, w, dist[<span class=\"number\">100005</span>];\nvector&lt;pair&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt;&gt; g[<span class=\"number\">100005</span>];\n\n<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">spfa</span><span class=\"params\">()</span> </span>&#123;\n    <span class=\"built_in\">memset</span>(dist, <span class=\"number\">0x3f</span>, <span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(dist));\n    dist[<span class=\"number\">1</span>] = <span class=\"number\">0</span>;\n    queue&lt;<span class=\"keyword\">int</span>&gt; q;\n    q.<span class=\"built_in\">push</span>(<span class=\"number\">1</span>);\n    <span class=\"keyword\">while</span> (!q.<span class=\"built_in\">empty</span>()) &#123;\n        <span class=\"keyword\">int</span> t = q.<span class=\"built_in\">front</span>();\n        q.<span class=\"built_in\">pop</span>();\n        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> i : g[t]) &#123;\n            <span class=\"keyword\">if</span> (dist[i.first] &gt; dist[t] + i.second) &#123;\n                dist[i.first] = dist[t] + i.second;\n                q.<span class=\"built_in\">push</span>(i.first);\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;\n    cin &gt;&gt; n &gt;&gt; m;\n    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++) &#123;\n        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;\n        g[u].<span class=\"built_in\">push_back</span>(<span class=\"built_in\">make_pair</span>(v, w));\n    &#125;\n    <span class=\"built_in\">spfa</span>();\n    <span class=\"keyword\">if</span> (dist[n] == <span class=\"number\">0x3f3f3f3f</span>) &#123;\n        cout &lt;&lt; <span class=\"string\">&quot;impossible&quot;</span> &lt;&lt; endl;\n    &#125; <span class=\"keyword\">else</span> &#123;\n        cout &lt;&lt; dist[n] &lt;&lt; endl;\n    &#125;\n    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;\n&#125;</code></pre>\n<p><strong>SPFA 判负环</strong></p>\n<p>题目：<a href=\"https://www.acwing.com/problem/content/854/\">852. spfa判断负环 - AcWing</a></p>\n<pre><code class=\"highlight cpp\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span>\n\n<span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;\n\n<span class=\"keyword\">int</span> n, m, u, v, w, dist[<span class=\"number\">100005</span>], cnt[<span class=\"number\">100005</span>];\nvector&lt;pair&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt;&gt; g[<span class=\"number\">100005</span>];\n\n<span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">spfa</span><span class=\"params\">()</span> </span>&#123;\n    <span class=\"built_in\">memset</span>(dist, <span class=\"number\">0x3f</span>, <span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(dist));\n    queue&lt;<span class=\"keyword\">int</span>&gt; q;\n    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;\n        q.<span class=\"built_in\">push</span>(i);\n    &#125;\n    <span class=\"keyword\">while</span> (!q.<span class=\"built_in\">empty</span>()) &#123;\n        <span class=\"keyword\">int</span> t = q.<span class=\"built_in\">front</span>();\n        q.<span class=\"built_in\">pop</span>();\n        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> i : g[t]) &#123;\n            <span class=\"keyword\">if</span> (dist[i.first] &gt; dist[t] + i.second) &#123;\n                dist[i.first] = dist[t] + i.second;\n                cnt[i.first] = cnt[t] + <span class=\"number\">1</span>;\n                <span class=\"keyword\">if</span> (cnt[i.first] &gt;= n) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;\n                q.<span class=\"built_in\">push</span>(i.first);\n            &#125;\n        &#125;\n    &#125;\n    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;\n&#125;\n\n<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;\n    cin &gt;&gt; n &gt;&gt; m;\n    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++) &#123;\n        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;\n        g[u].<span class=\"built_in\">push_back</span>(<span class=\"built_in\">make_pair</span>(v, w));\n    &#125;\n    cout &lt;&lt; (<span class=\"built_in\">spfa</span>() ? <span class=\"string\">&quot;Yes&quot;</span> : <span class=\"string\">&quot;No&quot;</span>) &lt;&lt; endl;\n    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;\n&#125;</code></pre>\n<h2 id=\"确定终点的最短路径问题\">确定终点的最短路径问题</h2>\n<p>与确定起点的问题相反，该问题是已知终结节点，求最短路径的问题。在无向图中该问题与确定起点的问题完全等同，在有向图中该问题等同于把所有路径方向反转的确定起点的问题。</p>\n<p>只需要反向存图然后再跑一遍单源最短路即可。</p>\n<h2 id=\"确定起点终点的最短路径问题\">确定起点终点的最短路径问题</h2>\n<p>即已知起点和终点，求两节点之间的最短路径。</p>\n<p>可以使用单源最短路算法并进行剪枝：在处理完到终点的最短路径后直接停止计算最短路。</p>\n<h2 id=\"全局最短路径问题\">全局最短路径问题</h2>\n<p>也叫多源最短路问题，求图中所有的最短路径。适合使用 Floyd 算法，时间复杂度为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>3</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^3)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">3</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> 。</p>\n<h3 id=\"实现-5\">实现</h3>\n<p>定义一个三维数组 <code>f[k][x][y]</code> ，表示只允许从 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">x</span></span></span></span> 点经过节点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn><mo>∼</mo><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">1 \\sim k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∼</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 点到 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>y</mi></mrow><annotation encoding=\"application/x-tex\">y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span></span></span></span> 点的最短距离，那么很容易得出从 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 点到 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 点的最短路径为 <code>f[n][1][n]</code> 。</p>\n<p>之后使用三重循环枚举即可。</p>\n<h3 id=\"代码-5\">代码</h3>\n<pre><code class=\"highlight cpp\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span>\n\n<span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;\n\n<span class=\"keyword\">int</span> n, m, k, x, y, z, f[<span class=\"number\">205</span>][<span class=\"number\">205</span>];\n\n<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;\n    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;\n        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt;= n; j++) &#123;\n            f[i][j] = i == j ? <span class=\"number\">0</span> : <span class=\"number\">0x3f3f3f3f3f</span>;\n        &#125;\n    &#125;\n    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= m; i++) &#123;\n        cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;\n        f[x][y] = <span class=\"built_in\">min</span>(f[x][y], z);\n    &#125;\n    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = <span class=\"number\">1</span>; k &lt;= n; k++) &#123;\n        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;\n            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt;= n; j++) &#123;\n                f[i][j] = <span class=\"built_in\">min</span>(f[i][j], f[i][k] + f[k][j]);\n            &#125;\n        &#125;\n    &#125;\n    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= k; i++) &#123;\n        cin &gt;&gt; x &gt;&gt; y;\n        <span class=\"keyword\">if</span> (f[x][y] &gt; <span class=\"number\">0x1fffffff</span>) &#123;\n            cout &lt;&lt; <span class=\"string\">&quot;impossible&quot;</span> &lt;&lt; endl;\n        &#125; <span class=\"keyword\">else</span> &#123;\n            cout &lt;&lt; f[x][y] &lt;&lt; endl;\n        &#125;\n    &#125;\n    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;\n&#125;</code></pre>\n<h2 id=\"参考资料\">参考资料</h2>\n<ol>\n<li><a href=\"https://oi-wiki.org/graph/shortest-path/\">最短路 - 图论 - OI Wiki</a></li>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98\">最短路问题 - 维基百科</a></li>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E6%88%B4%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95\">戴克斯特拉算法 (Dijkstra 算法) - 维基百科</a></li>\n<li><a href=\"https://zh.wikipedia.org/wiki/Floyd-Warshall%E7%AE%97%E6%B3%95\">Floyd-Warshall 算法 - 维基百科</a></li>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E8%B4%9D%E5%B0%94%E6%9B%BC-%E7%A6%8F%E7%89%B9%E7%AE%97%E6%B3%95\">Bellman-ford 算法 - 维基百科</a></li>\n<li><a href=\"https://www.zhihu.com/question/292283275/answer/484694411\">如何看待 SPFA 算法已死这种说法？ - immortalCO 的回答 - 知乎</a></li>\n</ol>\n<p><em>（文章头图来自《啊哈！算法》）</em></p>\n",
            "tags": [
                "算法",
                "图论",
                "笔记"
            ]
        },
        {
            "id": "https://blog.baoshuo.ren/post/segment-tree/",
            "url": "https://blog.baoshuo.ren/post/segment-tree/",
            "title": "线段树学习笔记",
            "date_published": "2020-12-02T00:08:39.000Z",
            "content_html": "<p>线段树（Segment Tree）是一种用来维护区间的数据结构。</p>\n<a id=\"more\"></a>\n<p>与树状数组相比，线段树可以实现时间复杂度在 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(\\log n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span> 级别的区间修改，还可以同时支持多种操作（加、乘、最值等）。</p>\n<h2 id=\"操作列表\">操作列表</h2>\n<ul>\n<li>上传（pushup）</li>\n<li>建树（build）</li>\n<li>下放懒标记（pushdown）</li>\n<li>区间查询（query）</li>\n<li>区间修改（modify）</li>\n</ul>\n<h2 id=\"通用操作\">通用操作</h2>\n<h3 id=\"存储线段树\">存储线段树</h3>\n<p>线段树是一个典型的二叉树，因此我们可以使用一个数组来存储线段树。</p>\n<p>分析：很容易就知道线段树的深度为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">⌈</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy=\"false\">⌉</mo></mrow><annotation encoding=\"application/x-tex\">\\lceil\\log n\\rceil</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">⌈</span><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">⌉</span></span></span></span> ，可得线段树的节点个数为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mrow><mrow><mo fence=\"true\">⌈</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo fence=\"true\">⌉</mo></mrow><mo>+</mo><mn>1</mn></mrow></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">2^{\\left\\lceil\\log{n}\\right\\rceil+1}-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9713299999999999em;vertical-align:-0.08333em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8879999999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"minner mtight\"><span class=\"mopen mtight delimcenter\" style=\"top:0em;\"><span class=\"mtight\">⌈</span></span><span class=\"mop mtight\"><span class=\"mtight\">l</span><span class=\"mtight\">o</span><span class=\"mtight\" style=\"margin-right:0.01389em;\">g</span></span><span class=\"mspace mtight\" style=\"margin-right:0.19516666666666668em;\"></span><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span><span class=\"mclose mtight delimcenter\" style=\"top:0em;\"><span class=\"mtight\">⌉</span></span></span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span>，粗略估计开大小为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>4</mn><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">4n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">4</span><span class=\"mord mathnormal\">n</span></span></span></span> 的数组即可（可以使用位运算写成 <code>n &lt;&lt; 2</code>）。</p>\n<pre><code class=\"highlight cpp\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span> &#123;</span>\n    <span class=\"keyword\">int</span> l, r;\n    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> s, d;\n\n    <span class=\"built_in\">node</span>() &#123;\n        l = r = s = d = <span class=\"number\">0</span>;\n    &#125;\n    <span class=\"built_in\">node</span>(<span class=\"keyword\">int</span> _l, <span class=\"keyword\">int</span> _r) &#123;\n        l = _l;\n        r = _r;\n        s = d = <span class=\"number\">0</span>;\n    &#125;\n&#125; tr[<span class=\"number\">100005</span> &lt;&lt; <span class=\"number\">2</span>];</code></pre>\n<table>\n<thead>\n<tr>\n<th>变量名</th>\n<th>用途</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>l</td>\n<td>区间的左端点</td>\n</tr>\n<tr>\n<td>r</td>\n<td>区间的右端点</td>\n</tr>\n<tr>\n<td>s</td>\n<td>区间和</td>\n</tr>\n<tr>\n<td>d</td>\n<td>懒标记</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"上传（pushup）\">上传（pushup）</h3>\n<p>之所以把上传放在建树前面说，是因为建树的时候要用到它。</p>\n<pre><code class=\"highlight cpp\"><span class=\"comment\">/**</span>\n<span class=\"comment\"> * 上传信息</span>\n<span class=\"comment\"> * @param u 父节点下标</span>\n<span class=\"comment\"> */</span>\n<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">pushup</span><span class=\"params\">(<span class=\"keyword\">int</span> u)</span> </span>&#123;\n    tr[u].s = tr[u &lt;&lt; <span class=\"number\">1</span>].s + tr[u &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].s;\n&#125;</code></pre>\n<p>将两个子节点所代表的区间的和相加即为父区间的和。</p>\n<h3 id=\"建树（build）\">建树（build）</h3>\n<pre><code class=\"highlight cpp\"><span class=\"comment\">/**</span>\n<span class=\"comment\"> * 建立线段树</span>\n<span class=\"comment\"> * @param u 根节点下标</span>\n<span class=\"comment\"> * @param l 左端点</span>\n<span class=\"comment\"> * @param r 右端点</span>\n<span class=\"comment\"> */</span>\n<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"keyword\">int</span> u, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span> </span>&#123;\n    tr[u] = <span class=\"built_in\">node</span>(l, r);\n    <span class=\"keyword\">if</span> (l == r) &#123;\n        tr[u].s = a[l];\n        <span class=\"keyword\">return</span>;\n    &#125;\n    <span class=\"keyword\">int</span> mid = l + r &gt;&gt; <span class=\"number\">1</span>;\n    <span class=\"built_in\">build</span>(u &lt;&lt; <span class=\"number\">1</span>, l, mid);\n    <span class=\"built_in\">build</span>(u &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, mid + <span class=\"number\">1</span>, r);\n    <span class=\"built_in\">pushup</span>(u);\n&#125;</code></pre>\n<p>先初始化当前区间，接下来分两种情况：</p>\n<ol>\n<li>若当前区间长度等于 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn><mtext>  </mtext><mo stretchy=\"false\">(</mo><mi>l</mi><mo>=</mo><mi>r</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">1\\ \\ (l = r)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mspace\"> </span><span class=\"mspace\"> </span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mclose\">)</span></span></span></span> ，则直接将当前区间的区间和赋值为 <code>a[l]</code> 即可。</li>\n<li>若当前区间长度大于 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn><mtext>  </mtext><mo stretchy=\"false\">(</mo><mi>l</mi><mo>&lt;</mo><mi>r</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">1\\ \\ (l &lt; r)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mspace\"> </span><span class=\"mspace\"> </span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mclose\">)</span></span></span></span> ，则将区间平均分成两部分（即从 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">⌊</mo><mo stretchy=\"false\">(</mo><mi>l</mi><mo>+</mo><mi>r</mi><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">/</mi><mn>2</mn><mo stretchy=\"false\">⌋</mo></mrow><annotation encoding=\"application/x-tex\">\\lfloor(l+r)/2\\rfloor</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">⌊</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mclose\">)</span><span class=\"mord\">/</span><span class=\"mord\">2</span><span class=\"mclose\">⌋</span></span></span></span> 处断开分为两个区间，可写作 <code>l + r &gt;&gt; 1</code>），继续向下递归建立左右子树即可。</li>\n</ol>\n<p>需要注意的是两个子区间没有交集，因此左子树的左端点是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>l</mi></mrow><annotation encoding=\"application/x-tex\">l</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span></span></span></span> 、右端点是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi><mi>i</mi><mi>d</mi></mrow><annotation encoding=\"application/x-tex\">mid</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">d</span></span></span></span> ，右子树的左端点是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi><mi>i</mi><mi>d</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">mid+1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.77777em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">d</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 、右端点是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>r</mi></mrow><annotation encoding=\"application/x-tex\">r</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span></span></span></span> 。</p>\n<h3 id=\"区间查询（query）\">区间查询（query）</h3>\n<pre><code class=\"highlight cpp\"><span class=\"comment\">/**</span>\n<span class=\"comment\"> * 区间查询</span>\n<span class=\"comment\"> * @param u 父节点</span>\n<span class=\"comment\"> * @param l 左端点</span>\n<span class=\"comment\"> * @param r 右端点</span>\n<span class=\"comment\"> */</span>\n<span class=\"function\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">int</span> u, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span> </span>&#123;\n    <span class=\"keyword\">if</span> (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) &#123;  <span class=\"comment\">// 被包含直接返回当前区间和</span>\n        <span class=\"keyword\">return</span> tr[u].s;\n    &#125;\n    <span class=\"keyword\">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class=\"number\">1</span>;\n    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> s = <span class=\"number\">0</span>;\n    <span class=\"built_in\">pushdown</span>(u);                                <span class=\"comment\">// 下放懒标记</span>\n    <span class=\"keyword\">if</span> (l &lt;= mid) s += <span class=\"built_in\">query</span>(u &lt;&lt; <span class=\"number\">1</span>, l, r);     <span class=\"comment\">// 和左侧有交集</span>\n    <span class=\"keyword\">if</span> (r &gt; mid) s += <span class=\"built_in\">query</span>(u &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, l, r);  <span class=\"comment\">// 和右侧有交集</span>\n    <span class=\"keyword\">return</span> s;\n&#125;</code></pre>\n<ol>\n<li>如果这个区间被包含，直接返回该区间的和。</li>\n<li>如果和左儿子区间有交集，则继续向左儿子区间递归查询。</li>\n<li>如果和右儿子区间有交集，则继续向右儿子区间递归查询。</li>\n</ol>\n<p>需要注意的是在递归查询左右儿子区间之前要先下放懒标记（pushdown），否则会出问题。</p>\n<h2 id=\"区间加\">区间加</h2>\n<p>本部分以 <a href=\"https://www.luogu.com.cn/problem/P3372\">洛谷 P3372 【模板】线段树 1</a> 为例子来简述一下线段树区间加的实现。</p>\n<h3 id=\"下放懒标记（pushdown）\">下放懒标记（pushdown）</h3>\n<pre><code class=\"highlight cpp\"><span class=\"comment\">/**</span>\n<span class=\"comment\"> * 下放懒标记</span>\n<span class=\"comment\"> * @param u 父节点下标</span>\n<span class=\"comment\"> */</span>\n<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">pushdown</span><span class=\"params\">(<span class=\"keyword\">int</span> u)</span> </span>&#123;\n    <span class=\"keyword\">if</span> (!tr[u].d) <span class=\"keyword\">return</span>;\n    <span class=\"comment\">// 处理左子树</span>\n    tr[u &lt;&lt; <span class=\"number\">1</span>].d += tr[u].d;\n    tr[u &lt;&lt; <span class=\"number\">1</span>].s += (tr[u &lt;&lt; <span class=\"number\">1</span>].r - tr[u &lt;&lt; <span class=\"number\">1</span>].l + <span class=\"number\">1</span>) * tr[u].d;\n    <span class=\"comment\">// 处理右子树</span>\n    tr[u &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].d += tr[u].d;\n    tr[u &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].s += (tr[u &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].r - tr[u &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].l + <span class=\"number\">1</span>) * tr[u].d;\n    <span class=\"comment\">// 清除懒标记</span>\n    tr[u].d = <span class=\"number\">0</span>;\n&#125;</code></pre>\n<p>这部分代码其实很简单。</p>\n<p>将左、右子树的懒标记加上父节点的懒标记，区间和加上 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>r</mi><mo>−</mo><mi>l</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo>×</mo><mi>d</mi></mrow><annotation encoding=\"application/x-tex\">(r - l + 1)\\times d</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.77777em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">d</span></span></span></span> （<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>r</mi><mo separator=\"true\">,</mo><mi>l</mi></mrow><annotation encoding=\"application/x-tex\">r, l</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span></span></span></span> 分别表示儿子区间的左、右端点，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>d</mi></mrow><annotation encoding=\"application/x-tex\">d</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">d</span></span></span></span>表示父节点的懒标记），最后清空父节点的懒标记即可。</p>\n<h3 id=\"区间修改（modify）\">区间修改（modify）</h3>\n<pre><code class=\"highlight cpp\"><span class=\"comment\">/**</span>\n<span class=\"comment\"> * 区间修改</span>\n<span class=\"comment\"> * @param u 父节点下标</span>\n<span class=\"comment\"> * @param l 左端点</span>\n<span class=\"comment\"> * @param r 右端点</span>\n<span class=\"comment\"> * @param d 增加的值</span>\n<span class=\"comment\"> */</span>\n<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">modify</span><span class=\"params\">(<span class=\"keyword\">int</span> u, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> d)</span> </span>&#123;\n    <span class=\"keyword\">if</span> (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) &#123;  <span class=\"comment\">// 被包含直接修改</span>\n        tr[u].d += d;\n        tr[u].s += (tr[u].r - tr[u].l + <span class=\"number\">1</span>) * d;\n        <span class=\"keyword\">return</span>;\n    &#125;\n    <span class=\"keyword\">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class=\"number\">1</span>;\n    <span class=\"built_in\">pushdown</span>(u);                               <span class=\"comment\">// 下放懒标记</span>\n    <span class=\"keyword\">if</span> (l &lt;= mid) <span class=\"built_in\">modify</span>(u &lt;&lt; <span class=\"number\">1</span>, l, r, d);     <span class=\"comment\">// 和左侧有交集</span>\n    <span class=\"keyword\">if</span> (r &gt; mid) <span class=\"built_in\">modify</span>(u &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, l, r, d);  <span class=\"comment\">// 和右侧有交集</span>\n    <span class=\"built_in\">pushup</span>(u);                                 <span class=\"comment\">// 上传新信息</span>\n&#125;</code></pre>\n<p>区间修改和区间查询的实现相似。</p>\n<ol>\n<li>如果当前区间被包含，直接添加懒标记并修改区间和。</li>\n<li>如果和左儿子区间有交集，则继续向左儿子区间递归修改。</li>\n<li>如果和右儿子区间有交集，则继续向右儿子区间递归修改。</li>\n</ol>\n<p>需要注意的是在递归修改左右儿子区间之前要先下放懒标记（pushdown），修改完成以后要上传新信息（pushup），否则会出问题。</p>\n<h2 id=\"区间加、乘\">区间加、乘</h2>\n<p>本部分以 <a href=\"https://www.luogu.com.cn/problem/P3373\">洛谷 P3373 【模板】线段树 2</a> 为例子来简述一下线段树区间加、乘的实现。</p>\n<p>在编写之前，结构体中需要先添加一个乘法的懒标记 <code>x</code> ，并将其赋初值为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> ，修改之后的结构体如下所示。</p>\n<pre><code class=\"highlight cpp\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span> &#123;</span>\n    <span class=\"keyword\">int</span> l, r;\n    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> s, d, x;\n\n    <span class=\"built_in\">node</span>() &#123;\n        l = r = s = d = <span class=\"number\">0</span>;\n        x = <span class=\"number\">1</span>;\n    &#125;\n    <span class=\"built_in\">node</span>(<span class=\"keyword\">int</span> _l, <span class=\"keyword\">int</span> _r) &#123;\n        l = _l, r = _r;\n        s = d = <span class=\"number\">0</span>;\n        x = <span class=\"number\">1</span>;\n    &#125;\n&#125; tr[<span class=\"number\">100005</span> &lt;&lt; <span class=\"number\">2</span>];</code></pre>\n<h3 id=\"下放懒标记（pushdown）-2\">下放懒标记（pushdown）</h3>\n<pre><code class=\"highlight cpp\"><span class=\"comment\">/**</span>\n<span class=\"comment\"> * 下放懒标记</span>\n<span class=\"comment\"> * @param u 父节点下标</span>\n<span class=\"comment\"> * @attention 先乘后加</span>\n<span class=\"comment\"> */</span>\n<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">pushdown</span><span class=\"params\">(<span class=\"keyword\">int</span> u)</span> </span>&#123;\n    <span class=\"comment\">// 左子树</span>\n    tr[u &lt;&lt; <span class=\"number\">1</span>].s = ((tr[u &lt;&lt; <span class=\"number\">1</span>].s * tr[u].x) + (tr[u &lt;&lt; <span class=\"number\">1</span>].r - tr[u &lt;&lt; <span class=\"number\">1</span>].l + <span class=\"number\">1</span>) * tr[u].d) % p;\n    tr[u &lt;&lt; <span class=\"number\">1</span>].x = tr[u &lt;&lt; <span class=\"number\">1</span>].x * tr[u].x % p;\n    tr[u &lt;&lt; <span class=\"number\">1</span>].d = (tr[u &lt;&lt; <span class=\"number\">1</span>].d * tr[u].x + tr[u].d) % p;\n    <span class=\"comment\">// 右子树</span>\n    tr[u &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].s = ((tr[u &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].s * tr[u].x) + (tr[u &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].r - tr[u &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].l + <span class=\"number\">1</span>) * tr[u].d) % p;\n    tr[u &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].x = tr[u &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].x * tr[u].x % p;\n    tr[u &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].d = (tr[u &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].d * tr[u].x + tr[u].d) % p;\n    <span class=\"comment\">// 清除懒标记</span>\n    tr[u].d = <span class=\"number\">0</span>;\n    tr[u].x = <span class=\"number\">1</span>;\n&#125;</code></pre>\n<p>此处遵循<strong>先乘后加</strong>的原则，先修改区间和，再修改乘法懒标记，最后修改加法懒标记，不要忘记 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext> </mtext><mo lspace=\"0.22em\" rspace=\"0.22em\"><mrow><mi mathvariant=\"normal\">m</mi><mi mathvariant=\"normal\">o</mi><mi mathvariant=\"normal\">d</mi></mrow></mo><mtext> </mtext><mtext> </mtext><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">\\bmod\\ p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mspace\" style=\"margin-right:0.05555555555555555em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathrm\">m</span><span class=\"mord mathrm\">o</span><span class=\"mord mathrm\">d</span></span></span><span class=\"mspace\" style=\"margin-right:0.05555555555555555em;\"></span><span class=\"mspace\"> </span><span class=\"mord mathnormal\">p</span></span></span></span>。</p>\n<p>注意：此处清除懒标记的时候，乘法懒标记应修改为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 。</p>\n<h3 id=\"区间修改（modify）-2\">区间修改（modify）</h3>\n<pre><code class=\"highlight cpp\"><span class=\"comment\">/**</span>\n<span class=\"comment\"> * 区间修改</span>\n<span class=\"comment\"> * @details 修改区间 [l, r] 中的每一个数</span>\n<span class=\"comment\"> * @param u 父节点下标</span>\n<span class=\"comment\"> * @param l 左端点</span>\n<span class=\"comment\"> * @param r 右端点</span>\n<span class=\"comment\"> * @param x 乘上的数</span>\n<span class=\"comment\"> * @param d 增加的值</span>\n<span class=\"comment\"> */</span>\n<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">modify</span><span class=\"params\">(<span class=\"keyword\">int</span> u, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> x, <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> d)</span> </span>&#123;\n    <span class=\"comment\">// 被包含直接修改</span>\n    <span class=\"keyword\">if</span> (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) &#123;\n        tr[u].s = ((tr[u].s * x) + (tr[u].r - tr[u].l + <span class=\"number\">1</span>) * d) % p;\n        tr[u].x = tr[u].x * x % p;\n        tr[u].d = (tr[u].d * x + d) % p;\n        <span class=\"keyword\">return</span>;\n    &#125;\n    <span class=\"keyword\">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class=\"number\">1</span>;\n    <span class=\"built_in\">pushdown</span>(u);                                  <span class=\"comment\">// 下放懒标记</span>\n    <span class=\"keyword\">if</span> (l &lt;= mid) <span class=\"built_in\">modify</span>(u &lt;&lt; <span class=\"number\">1</span>, l, r, x, d);     <span class=\"comment\">// 和左侧有交集</span>\n    <span class=\"keyword\">if</span> (r &gt; mid) <span class=\"built_in\">modify</span>(u &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, l, r, x, d);  <span class=\"comment\">// 和右侧有交集</span>\n    <span class=\"built_in\">pushup</span>(u);                                    <span class=\"comment\">// 上传新信息</span>\n&#125;</code></pre>\n<p>大体上和加法的修改函数一样，而在修改时与下放懒标记做法相同，遵循<strong>先乘后加</strong>的原则。</p>\n<p>调用的时候若只需要使用乘法部分，加数设置为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span> 即可。若只需要使用加法部分，乘数设置为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 即可。</p>\n<h2 id=\"全部代码\">全部代码</h2>\n<p>到这里基本操作就说完了，下面是全部的 AC 代码。</p>\n<h3 id=\"区间加-2\">区间加</h3>\n<pre><code class=\"highlight cpp\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span>\n\n<span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;\n\n<span class=\"comment\">/**</span>\n<span class=\"comment\"> * 线段树节点</span>\n<span class=\"comment\"> */</span>\n<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span> &#123;</span>\n    <span class=\"keyword\">int</span> l, r;\n    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> s, d;\n\n    <span class=\"built_in\">node</span>() &#123;\n        l = r = s = d = <span class=\"number\">0</span>;\n    &#125;\n    <span class=\"built_in\">node</span>(<span class=\"keyword\">int</span> _l, <span class=\"keyword\">int</span> _r) &#123;\n        l = _l;\n        r = _r;\n        s = d = <span class=\"number\">0</span>;\n    &#125;\n&#125; tr[<span class=\"number\">100005</span> &lt;&lt; <span class=\"number\">2</span>];\n<span class=\"keyword\">int</span> n, m, op, x, y, k, a[<span class=\"number\">100005</span>];\n\n<span class=\"comment\">/**</span>\n<span class=\"comment\"> * 上传区间和</span>\n<span class=\"comment\"> * @param u 父节点下标</span>\n<span class=\"comment\"> */</span>\n<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">pushup</span><span class=\"params\">(<span class=\"keyword\">int</span> u)</span> </span>&#123;\n    tr[u].s = tr[u &lt;&lt; <span class=\"number\">1</span>].s + tr[u &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].s;\n&#125;\n\n<span class=\"comment\">/**</span>\n<span class=\"comment\"> * 下放懒标记</span>\n<span class=\"comment\"> * @param u 父节点下标</span>\n<span class=\"comment\"> */</span>\n<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">pushdown</span><span class=\"params\">(<span class=\"keyword\">int</span> u)</span> </span>&#123;\n    <span class=\"keyword\">if</span> (!tr[u].d) <span class=\"keyword\">return</span>;\n    <span class=\"comment\">// 处理左子树</span>\n    tr[u &lt;&lt; <span class=\"number\">1</span>].d += tr[u].d;\n    tr[u &lt;&lt; <span class=\"number\">1</span>].s += (tr[u &lt;&lt; <span class=\"number\">1</span>].r - tr[u &lt;&lt; <span class=\"number\">1</span>].l + <span class=\"number\">1</span>) * tr[u].d;\n    <span class=\"comment\">// 处理右子树</span>\n    tr[u &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].d += tr[u].d;\n    tr[u &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].s += (tr[u &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].r - tr[u &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].l + <span class=\"number\">1</span>) * tr[u].d;\n    <span class=\"comment\">// 清除懒标记</span>\n    tr[u].d = <span class=\"number\">0</span>;\n&#125;\n\n<span class=\"comment\">/**</span>\n<span class=\"comment\"> * 建立线段树</span>\n<span class=\"comment\"> * @param u 根节点下标</span>\n<span class=\"comment\"> * @param l 左端点</span>\n<span class=\"comment\"> * @param r 右端点</span>\n<span class=\"comment\"> */</span>\n<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"keyword\">int</span> u, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span> </span>&#123;\n    tr[u] = <span class=\"built_in\">node</span>(l, r);\n    <span class=\"keyword\">if</span> (l == r) &#123;\n        tr[u].s = a[l];\n        <span class=\"keyword\">return</span>;\n    &#125;\n    <span class=\"keyword\">int</span> mid = l + r &gt;&gt; <span class=\"number\">1</span>;\n    <span class=\"built_in\">build</span>(u &lt;&lt; <span class=\"number\">1</span>, l, mid);\n    <span class=\"built_in\">build</span>(u &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, mid + <span class=\"number\">1</span>, r);\n    <span class=\"built_in\">pushup</span>(u);\n&#125;\n\n<span class=\"comment\">/**</span>\n<span class=\"comment\"> * 区间修改</span>\n<span class=\"comment\"> * @param u 父节点下标</span>\n<span class=\"comment\"> * @param l 左端点</span>\n<span class=\"comment\"> * @param r 右端点</span>\n<span class=\"comment\"> * @param d 增加的值</span>\n<span class=\"comment\"> */</span>\n<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">modify</span><span class=\"params\">(<span class=\"keyword\">int</span> u, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> d)</span> </span>&#123;\n    <span class=\"keyword\">if</span> (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) &#123;  <span class=\"comment\">// 被包含直接修改</span>\n        tr[u].d += d;\n        tr[u].s += (tr[u].r - tr[u].l + <span class=\"number\">1</span>) * d;\n        <span class=\"keyword\">return</span>;\n    &#125;\n    <span class=\"keyword\">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class=\"number\">1</span>;\n    <span class=\"built_in\">pushdown</span>(u);                               <span class=\"comment\">// 下放懒标记</span>\n    <span class=\"keyword\">if</span> (l &lt;= mid) <span class=\"built_in\">modify</span>(u &lt;&lt; <span class=\"number\">1</span>, l, r, d);     <span class=\"comment\">// 和左侧有交集</span>\n    <span class=\"keyword\">if</span> (r &gt; mid) <span class=\"built_in\">modify</span>(u &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, l, r, d);  <span class=\"comment\">// 和右侧有交集</span>\n    <span class=\"built_in\">pushup</span>(u);                                 <span class=\"comment\">// 上传新信息</span>\n&#125;\n\n<span class=\"comment\">/**</span>\n<span class=\"comment\"> * 区间查询</span>\n<span class=\"comment\"> * @param u 父节点</span>\n<span class=\"comment\"> * @param l 左端点</span>\n<span class=\"comment\"> * @param r 右端点</span>\n<span class=\"comment\"> */</span>\n<span class=\"function\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">int</span> u, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span> </span>&#123;\n    <span class=\"keyword\">if</span> (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) &#123;  <span class=\"comment\">// 被包含直接返回</span>\n        <span class=\"keyword\">return</span> tr[u].s;\n    &#125;\n    <span class=\"keyword\">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class=\"number\">1</span>;\n    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> s = <span class=\"number\">0</span>;\n    <span class=\"built_in\">pushdown</span>(u);                                <span class=\"comment\">// 下放懒标记</span>\n    <span class=\"keyword\">if</span> (l &lt;= mid) s += <span class=\"built_in\">query</span>(u &lt;&lt; <span class=\"number\">1</span>, l, r);     <span class=\"comment\">// 和左侧有交集</span>\n    <span class=\"keyword\">if</span> (r &gt; mid) s += <span class=\"built_in\">query</span>(u &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, l, r);  <span class=\"comment\">// 和右侧有交集</span>\n    <span class=\"keyword\">return</span> s;\n&#125;\n\n<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;\n    cin &gt;&gt; n &gt;&gt; m;\n    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;\n        cin &gt;&gt; a[i];\n    &#125;\n    <span class=\"built_in\">build</span>(<span class=\"number\">1</span>, <span class=\"number\">1</span>, n);\n    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++) &#123;\n        cin &gt;&gt; op &gt;&gt; x &gt;&gt; y;\n        <span class=\"keyword\">if</span> (op == <span class=\"number\">1</span>) &#123;\n            cin &gt;&gt; k;\n            <span class=\"built_in\">modify</span>(<span class=\"number\">1</span>, x, y, k);\n        &#125;\n        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (op == <span class=\"number\">2</span>) &#123;\n            cout &lt;&lt; <span class=\"built_in\">query</span>(<span class=\"number\">1</span>, x, y) &lt;&lt; endl;\n        &#125;\n    &#125;\n    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;\n&#125;</code></pre>\n<h3 id=\"区间加、乘-2\">区间加、乘</h3>\n<pre><code class=\"highlight cpp\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span>\n\n<span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;\n\n<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span> &#123;</span>\n    <span class=\"keyword\">int</span> l, r;\n    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> s, d, x;\n\n    <span class=\"built_in\">node</span>() &#123;\n        l = r = s = d = <span class=\"number\">0</span>;\n        x = <span class=\"number\">1</span>;\n    &#125;\n    <span class=\"built_in\">node</span>(<span class=\"keyword\">int</span> _l, <span class=\"keyword\">int</span> _r) &#123;\n        l = _l, r = _r;\n        s = d = <span class=\"number\">0</span>;\n        x = <span class=\"number\">1</span>;\n    &#125;\n&#125; tr[<span class=\"number\">100005</span> &lt;&lt; <span class=\"number\">2</span>];\n<span class=\"keyword\">int</span> n, m, p, op, x, y;\n<span class=\"keyword\">long</span> <span class=\"keyword\">long</span> k, a[<span class=\"number\">100005</span>];\n\n<span class=\"comment\">/**</span>\n<span class=\"comment\"> * 上传信息</span>\n<span class=\"comment\"> * @param u 父节点下标</span>\n<span class=\"comment\"> */</span>\n<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">pushup</span><span class=\"params\">(<span class=\"keyword\">int</span> u)</span> </span>&#123;\n    tr[u].s = (tr[u &lt;&lt; <span class=\"number\">1</span>].s + tr[u &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].s) % p;\n&#125;\n\n<span class=\"comment\">/**</span>\n<span class=\"comment\"> * 下放懒标记</span>\n<span class=\"comment\"> * @param u 父节点下标</span>\n<span class=\"comment\"> * @attention 先乘后加</span>\n<span class=\"comment\"> */</span>\n<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">pushdown</span><span class=\"params\">(<span class=\"keyword\">int</span> u)</span> </span>&#123;\n    <span class=\"comment\">// 左子树</span>\n    tr[u &lt;&lt; <span class=\"number\">1</span>].s = ((tr[u &lt;&lt; <span class=\"number\">1</span>].s * tr[u].x) + (tr[u &lt;&lt; <span class=\"number\">1</span>].r - tr[u &lt;&lt; <span class=\"number\">1</span>].l + <span class=\"number\">1</span>) * tr[u].d) % p;\n    tr[u &lt;&lt; <span class=\"number\">1</span>].x = tr[u &lt;&lt; <span class=\"number\">1</span>].x * tr[u].x % p;\n    tr[u &lt;&lt; <span class=\"number\">1</span>].d = (tr[u &lt;&lt; <span class=\"number\">1</span>].d * tr[u].x + tr[u].d) % p;\n    <span class=\"comment\">// 右子树</span>\n    tr[u &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].s = ((tr[u &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].s * tr[u].x) + (tr[u &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].r - tr[u &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].l + <span class=\"number\">1</span>) * tr[u].d) % p;\n    tr[u &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].x = tr[u &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].x * tr[u].x % p;\n    tr[u &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].d = (tr[u &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].d * tr[u].x + tr[u].d) % p;\n    <span class=\"comment\">// 清除懒标记</span>\n    tr[u].d = <span class=\"number\">0</span>;\n    tr[u].x = <span class=\"number\">1</span>;\n&#125;\n\n<span class=\"comment\">/**</span>\n<span class=\"comment\"> * 建立线段树</span>\n<span class=\"comment\"> * @param u 根节点下标</span>\n<span class=\"comment\"> * @param l 左端点</span>\n<span class=\"comment\"> * @param r 右端点</span>\n<span class=\"comment\"> */</span>\n<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"keyword\">int</span> u, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span> </span>&#123;\n    tr[u] = <span class=\"built_in\">node</span>(l, r);\n    <span class=\"keyword\">if</span> (l == r) &#123;\n        tr[u].s = a[l] % p;\n        <span class=\"keyword\">return</span>;\n    &#125;\n    <span class=\"keyword\">int</span> mid = l + r &gt;&gt; <span class=\"number\">1</span>;\n    <span class=\"built_in\">build</span>(u &lt;&lt; <span class=\"number\">1</span>, l, mid);\n    <span class=\"built_in\">build</span>(u &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, mid + <span class=\"number\">1</span>, r);\n    <span class=\"built_in\">pushup</span>(u);\n&#125;\n\n<span class=\"comment\">/**</span>\n<span class=\"comment\"> * 区间修改</span>\n<span class=\"comment\"> * @details 将区间 [l, r] 中的每一个数加上 d</span>\n<span class=\"comment\"> * @param u 父节点下标</span>\n<span class=\"comment\"> * @param l 左端点</span>\n<span class=\"comment\"> * @param r 右端点</span>\n<span class=\"comment\"> * @param x 乘上的数</span>\n<span class=\"comment\"> * @param d 增加的值</span>\n<span class=\"comment\"> */</span>\n<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">modify</span><span class=\"params\">(<span class=\"keyword\">int</span> u, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> x, <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> d)</span> </span>&#123;\n    <span class=\"comment\">// 被包含直接修改</span>\n    <span class=\"keyword\">if</span> (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) &#123;\n        tr[u].s = ((tr[u].s * x) + (tr[u].r - tr[u].l + <span class=\"number\">1</span>) * d) % p;\n        tr[u].x = tr[u].x * x % p;\n        tr[u].d = (tr[u].d * x + d) % p;\n        <span class=\"keyword\">return</span>;\n    &#125;\n    <span class=\"keyword\">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class=\"number\">1</span>;\n    <span class=\"built_in\">pushdown</span>(u);                                  <span class=\"comment\">// 下放懒标记</span>\n    <span class=\"keyword\">if</span> (l &lt;= mid) <span class=\"built_in\">modify</span>(u &lt;&lt; <span class=\"number\">1</span>, l, r, x, d);     <span class=\"comment\">// 和左侧有交集</span>\n    <span class=\"keyword\">if</span> (r &gt; mid) <span class=\"built_in\">modify</span>(u &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, l, r, x, d);  <span class=\"comment\">// 和右侧有交集</span>\n    <span class=\"built_in\">pushup</span>(u);                                    <span class=\"comment\">// 上传新信息</span>\n&#125;\n\n<span class=\"comment\">/**</span>\n<span class=\"comment\"> * 区间查询</span>\n<span class=\"comment\"> * @param u </span>\n<span class=\"comment\"> * @param l </span>\n<span class=\"comment\"> * @param r </span>\n<span class=\"comment\"> * @return int </span>\n<span class=\"comment\"> */</span>\n<span class=\"function\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">int</span> u, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span> </span>&#123;\n    <span class=\"keyword\">if</span> (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) &#123;  <span class=\"comment\">// 被包含直接返回</span>\n        <span class=\"keyword\">return</span> tr[u].s;\n    &#125;\n    <span class=\"keyword\">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class=\"number\">1</span>;\n    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> s = <span class=\"number\">0</span>;\n    <span class=\"built_in\">pushdown</span>(u);                                         <span class=\"comment\">// 下放懒标记</span>\n    <span class=\"keyword\">if</span> (l &lt;= mid) s = <span class=\"built_in\">query</span>(u &lt;&lt; <span class=\"number\">1</span>, l, r);               <span class=\"comment\">// 和左侧有交集</span>\n    <span class=\"keyword\">if</span> (r &gt; mid) s = (s + <span class=\"built_in\">query</span>(u &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, l, r)) % p;  <span class=\"comment\">// 和右侧有交集</span>\n    <span class=\"keyword\">return</span> s;\n&#125;\n\n<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; p;\n    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;\n        cin &gt;&gt; a[i];\n    &#125;\n    <span class=\"built_in\">build</span>(<span class=\"number\">1</span>, <span class=\"number\">1</span>, n);\n    <span class=\"keyword\">while</span> (m--) &#123;\n        cin &gt;&gt; op &gt;&gt; x &gt;&gt; y;\n        <span class=\"keyword\">if</span> (op == <span class=\"number\">1</span>) &#123;\n            cin &gt;&gt; k;\n            <span class=\"built_in\">modify</span>(<span class=\"number\">1</span>, x, y, k, <span class=\"number\">0</span>);\n        &#125;\n        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (op == <span class=\"number\">2</span>) &#123;\n            cin &gt;&gt; k;\n            <span class=\"built_in\">modify</span>(<span class=\"number\">1</span>, x, y, <span class=\"number\">1</span>, k);\n        &#125;\n        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (op == <span class=\"number\">3</span>) &#123;\n            cout &lt;&lt; <span class=\"built_in\">query</span>(<span class=\"number\">1</span>, x, y) % p &lt;&lt; endl;\n        &#125;\n    &#125;\n    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;\n&#125;</code></pre>",
            "tags": [
                "笔记"
            ]
        }
    ]
}