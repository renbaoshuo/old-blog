{
    "version": "https://jsonfeed.org/version/1",
    "title": "宝硕博客 • All posts by \"javascript\" tag",
    "description": "宝硕博客 —— Baoshuo (@renbaoshuo) 随便写东西的地方，以技术向博文为主，生活向博文为辅。",
    "home_page_url": "https://blog.baoshuo.ren",
    "items": [
        {
            "id": "https://blog.baoshuo.ren/post/workbox-service-worker/",
            "url": "https://blog.baoshuo.ren/post/workbox-service-worker/",
            "title": "初识 Service Worker —— 使用 Workbox 快速开发 Service Worker",
            "date_published": "2021-02-27T16:02:04.000Z",
            "content_html": "<p>对于优化前端加载性能这个问题，许多人以 http-cache、异步加载、304 状态码、文件压缩、CDN 等方法来解决。<br>\n其实除了这些方法，还有一个比它们都强大的，那就是 Service Worker 。</p>\n<a id=\"more\"></a>\n<p>我们可以使用 Google Chrome 团队的 <a href=\"https://github.com/GoogleChrome/workbox\">Workbox</a> 来实现 Service Worker 的快速开发。</p>\n<h2 id=\"注册-Service-Worker\">注册 Service Worker</h2>\n<p>在页面中添加以下内容以注册一个 Service Worker 。</p>\n<pre><code class=\"highlight html\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span>\n<span class=\"javascript\">    <span class=\"comment\">// 检测是否支持 Service Worker</span></span>\n<span class=\"javascript\">    <span class=\"comment\">// 也可使用 navigator.serviceWorker 判断</span></span>\n<span class=\"javascript\">    <span class=\"keyword\">if</span> (<span class=\"string\">&#x27;serviceWorker&#x27;</span> <span class=\"keyword\">in</span> navigator) &#123; </span>\n<span class=\"javascript\">        <span class=\"comment\">// 为了保证首屏渲染性能，在页面 onload 完之后注册 Service Worker</span></span>\n<span class=\"javascript\">        <span class=\"comment\">// 不使用 window.onload 以免冲突   </span></span>\n<span class=\"javascript\">        <span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">&#x27;load&#x27;</span>, <span class=\"function\">() =&gt;</span> &#123;</span>\n<span class=\"javascript\">            navigator.serviceWorker.register(<span class=\"string\">&#x27;/sw.js&#x27;</span>);</span>\n        &#125;);\n    &#125;\n<span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></code></pre>\n<p>当然，在这之前你需要先有一个 Service Worker 的代码 <code>/sw.js</code> 。</p>\n<p>你可以在这个文件中写入以下代码来检测是否成功地注册了 Service Worker 。</p>\n<pre><code class=\"highlight javascript\"><span class=\"built_in\">console</span>.clear();\n<span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;Successful registered service worker.&#x27;</span>);</code></pre>\n<p><img src=\"https://vip2.loli.io/2021/02/28/Eu4mVIC2kNrUgiL.png\" alt=\"控制台输出\" loading=\"lazy\" data-action=\"zoom\"><span class=\"image-description\">控制台输出</span></p>\n<h2 id=\"引入-Workbox\">引入 Workbox</h2>\n<p>你可以使用 Google 提供的 CDN 来引入 Workbox 。<br>\n只需在 <code>sw.js</code> 的开头写入以下内容即可：</p>\n<pre><code class=\"highlight javascript\">importScripts(<span class=\"string\">&#x27;https://storage.googleapis.com/workbox-cdn/releases/6.1.1/workbox-sw.js&#x27;</span>);</code></pre>\n<p>如果你觉得 Google 的 CDN 不太靠谱的话，可以使用 <code>workbox-cli</code> 将资源存在本地：</p>\n<pre><code class=\"highlight bash\">npm i workbox-cli -g\nworkbox copyLibraries &#123;path/to/workbox/&#125;</code></pre>\n<p>这时需要在 <code>sw.js</code> 的开头将上方写入的内容替换为以下内容即可：</p>\n<pre><code class=\"highlight javascript\">importScripts(<span class=\"string\">&#x27;&#123;path/to&#125;/workbox/workbox-sw.js&#x27;</span>);\nworkbox.setConfig(&#123;\n    modulePathPrefix: <span class=\"string\">&#x27;&#123;path/to&#125;/workbox/&#x27;</span>\n&#125;);</code></pre>\n<h2 id=\"Workbox-策略\">Workbox 策略</h2>\n<h3 id=\"Stale-While-Revalidate（重新验证时过期）\">Stale While Revalidate（重新验证时过期）</h3>\n<p><img src=\"https://vip1.loli.io/2021/02/28/rx8zafbqPe1JnkX.png\" alt=\"工作流程示意图\" loading=\"lazy\" data-action=\"zoom\"><span class=\"image-description\">工作流程示意图</span></p>\n<p>此策略将对网络请求使用缓存来响应（如果有），并在后台更新缓存。如果未缓存，它将等待网络响应并使用它。<br>\n这是一个相当安全的策略，因为这意味着用户会定期更新其缓存。这种策略的缺点是：它总是从网络上请求资源，较为浪费用户的带宽。</p>\n<pre><code class=\"highlight javascript\">registerRoute(\n    <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(matchString),\n    <span class=\"keyword\">new</span> workbox.strategies.StaleWhileRevalidate()\n);</code></pre>\n<h3 id=\"Network-First（网络优先）\">Network First（网络优先）</h3>\n<p><img src=\"https://vip2.loli.io/2021/02/28/9ViWk1ZyU4CuDxE.png\" alt=\"工作流程示意图\" loading=\"lazy\" data-action=\"zoom\"><span class=\"image-description\">工作流程示意图</span></p>\n<p>此策略将尝试首先从网络获得响应。如果收到响应，它将把它传递给浏览器，并将其保存到缓存中。如果网络请求失败，将使用最后一个缓存的响应。</p>\n<pre><code class=\"highlight javascript\">registerRoute(\n    <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(matchString),\n    <span class=\"keyword\">new</span> workbox.strategies.NetworkFirst()\n);</code></pre>\n<h3 id=\"Cache-First（缓存优先）\">Cache First（缓存优先）</h3>\n<p><img src=\"https://vip1.loli.io/2021/02/28/jkn4Y3mNCRZrSdX.png\" alt=\"工作流程示意图\" loading=\"lazy\" data-action=\"zoom\"><span class=\"image-description\">工作流程示意图</span></p>\n<p>此策略将首先检查缓存中是否有响应，如果有响应，则使用该策略。如果请求不在缓存中，则将使用网络，并将任何有效响应添加到缓存中，然后再传递给浏览器。</p>\n<pre><code class=\"highlight javascript\">registerRoute(\n    <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(matchString),\n    <span class=\"keyword\">new</span> workbox.strategies.CacheFirst()\n);</code></pre>\n<h3 id=\"Network-Only（仅网络）\">Network Only（仅网络）</h3>\n<p><img src=\"https://vip2.loli.io/2021/02/28/cQYTlvie1dX8hOF.png\" alt=\"工作流程示意图\" loading=\"lazy\" data-action=\"zoom\"><span class=\"image-description\">工作流程示意图</span></p>\n<p>强制响应来自网络。</p>\n<pre><code class=\"highlight javascript\">registerRoute(\n    <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(matchString),\n    <span class=\"keyword\">new</span> workbox.strategies.NetworkOnly()\n);</code></pre>\n<h3 id=\"Cache-Only（仅缓存）\">Cache Only（仅缓存）</h3>\n<p><img src=\"https://vip1.loli.io/2021/02/28/71Sw5tTaBQKl8ri.png\" alt=\"工作流程示意图\" loading=\"lazy\" data-action=\"zoom\"><span class=\"image-description\">工作流程示意图</span></p>\n<p>强制响应来自缓存。</p>\n<pre><code class=\"highlight javascript\">registerRoute(\n    <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(matchString),\n    <span class=\"keyword\">new</span> workbox.strategies.CacheOnly()\n);</code></pre>\n<h3 id=\"策略配置\">策略配置</h3>\n<p>可以通过定义要使用的插件来自定义路由的行为。</p>\n<pre><code class=\"highlight javascript\"><span class=\"keyword\">new</span> workbox.strategies.StaleWhileRevalidate(&#123;\n    <span class=\"comment\">// Use a custom cache for this route.</span>\n    cacheName: <span class=\"string\">&#x27;my-cache-name&#x27;</span>,\n\n    <span class=\"comment\">// Add an array of custom plugins (e.g. `ExpirationPlugin`).</span>\n    plugins: [\n        ...\n    ]\n&#125;);</code></pre>\n<h2 id=\"Workbox-中的自定义策略\">Workbox 中的自定义策略</h2>\n<p>在某些情况下，您可能希望使用自己的其他策略来响应请求，或者只是通过模板在 Service Worker 中生成请求。<br>\n为此可以提供一个异步返回 <code>Response</code> 对象的函数 <code>handler</code> 。</p>\n<pre><code class=\"highlight javascript\"><span class=\"keyword\">const</span> handler = <span class=\"keyword\">async</span> (&#123; url, event &#125;) =&gt; &#123;\n  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Response(<span class=\"string\">`Custom handler response.`</span>);\n&#125;;\n\nworkbox.routing.registerRoute(\n    <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(matchString),\n    handler\n);</code></pre>\n<p>需要注意的是，如果在 <code>match</code> 回调中返回一个值，它将 <code>handler</code> 作为 <code>params</code> 参数传递到回调中。</p>\n<pre><code class=\"highlight javascript\"><span class=\"keyword\">const</span> match = <span class=\"function\">(<span class=\"params\">&#123; url, event &#125;</span>) =&gt;</span> &#123;\n    <span class=\"keyword\">if</span> (url.pathname === <span class=\"string\">&#x27;/example&#x27;</span>) &#123;\n        <span class=\"keyword\">return</span> &#123;\n            name: <span class=\"string\">&#x27;Workbox&#x27;</span>,\n            type: <span class=\"string\">&#x27;guide&#x27;</span>,\n        &#125;;\n    &#125;\n&#125;;\n\n<span class=\"keyword\">const</span> handler = <span class=\"keyword\">async</span> (&#123; url, event, params &#125;) =&gt; &#123;\n    <span class=\"comment\">// Response will be &quot;A guide to Workbox&quot;</span>\n    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Response(\n        <span class=\"string\">`A <span class=\"subst\">$&#123;params.type&#125;</span> to <span class=\"subst\">$&#123;params.name&#125;</span>`</span>\n    );\n&#125;;\n\nworkbox.routing.registerRoute(match, handler);</code></pre>\n<p>如果 URL 中的某些信息可以在 match 回调中解析一次并在中使用，则这可能会对 <code>handler</code> 有所帮助。</p>\n<h2 id=\"Workbox-实践\">Workbox 实践</h2>\n<p>通常对于大部分项目使用 Workbox 时一般会引入相应的 gulp 或者 webpack 插件，在构建流程中完成对 Service Worker 的注册、将指定 URL 进行 Precache、完成 sw.js 的生成，等等。<br>\n但是对于 Hexo、Jekyll 这些静态站点生成器或者 WordPress、Typecho 这些 CMS，如果不安装相应的插件，就需要自己从头编写一个 <code>sw.js</code>。</p>\n<p>先写一下总的配置：</p>\n<pre><code class=\"highlight javascript\"><span class=\"keyword\">let</span> cacheSuffixVersion = <span class=\"string\">&#x27;-210227&#x27;</span>;  <span class=\"comment\">// 缓存版本号</span>\n<span class=\"keyword\">const</span> maxEntries = <span class=\"number\">100</span>;              <span class=\"comment\">// 最大条目数</span>\n\ncore.setCacheNameDetails(&#123;\n    prefix: <span class=\"string\">&#x27;baoshuo-blog&#x27;</span>,          <span class=\"comment\">// 前缀</span>\n    suffix: cacheSuffixVersion       <span class=\"comment\">// 后缀</span>\n&#125;);</code></pre>\n<h3 id=\"Google-Fonts\">Google Fonts</h3>\n<p>Google Fonts 主要使用两个域名：<code>fonts.googleapis.com</code> 和 <code>fonts.gstatic.com</code> ，因此只需在匹配到这两个域名时进行缓存。</p>\n<pre><code class=\"highlight javascript\">workbox.routing.registerRoute(\n    <span class=\"comment\">// 匹配 fonts.googleapis.com 和 fonts.gstatic.com 两个域名</span>\n    <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(<span class=\"string\">&#x27;^https://(?:fonts\\\\.googleapis\\\\.com|fonts\\\\.gstatic\\\\.com)&#x27;</span>),\n    <span class=\"keyword\">new</span> workbox.strategies.StaleWhileRevalidate(&#123;\n        <span class=\"comment\">// cache storage 名称和版本号</span>\n        cacheName: <span class=\"string\">&#x27;font-cache&#x27;</span> + cacheSuffixVersion,\n        plugins: [\n            <span class=\"comment\">// 使用 expiration 插件实现缓存条目数目和时间控制</span>\n            <span class=\"keyword\">new</span> workbox.expiration.ExpirationPlugin(&#123;\n                <span class=\"comment\">// 最大保存项目</span>\n                maxEntries,\n                <span class=\"comment\">// 缓存 30 天</span>\n                maxAgeSeconds: <span class=\"number\">30</span> * <span class=\"number\">24</span> * <span class=\"number\">60</span> * <span class=\"number\">60</span>,\n            &#125;),\n            <span class=\"comment\">// 使用 cacheableResponse 插件缓存状态码为 0 的请求</span>\n            <span class=\"keyword\">new</span> workbox.cacheableResponse.CacheableResponsePlugin(&#123;\n                statuses: [<span class=\"number\">0</span>, <span class=\"number\">200</span>],\n            &#125;),\n        ]\n    &#125;)\n);</code></pre>\n<h3 id=\"jsDelivr-CDN\">jsDelivr CDN</h3>\n<p>使用 jsDelivr CDN 时如果指定了库的版本，对应的文件可以称得上是永久不会改变的，所以使用 <code>CacheFirst</code> 来进行缓存。</p>\n<pre><code class=\"highlight javascript\">workbox.routing.registerRoute(\n    <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(<span class=\"string\">&#x27;^https://cdn\\\\.jsdelivr\\\\.net&#x27;</span>),\n    <span class=\"keyword\">new</span> workbox.strategies.CacheFirst(&#123;\n        cacheName: <span class=\"string\">&#x27;static-immutable&#x27;</span> + cacheSuffixVersion,\n        fetchOptions: &#123;\n            mode: <span class=\"string\">&#x27;cors&#x27;</span>,\n            credentials: <span class=\"string\">&#x27;omit&#x27;</span>\n        &#125;,\n        plugins: [\n            <span class=\"keyword\">new</span> workbox.expiration.ExpirationPlugin(&#123;\n                maxAgeSeconds: <span class=\"number\">30</span> * <span class=\"number\">24</span> * <span class=\"number\">60</span> * <span class=\"number\">60</span>,\n                purgeOnQuotaError: <span class=\"literal\">true</span>\n            &#125;)\n        ]\n    &#125;)\n);</code></pre>\n<h3 id=\"Google-Analytics\">Google Analytics</h3>\n<p>Workbox 有一个 <a href=\"https://developers.google.com/web/tools/workbox/guides/enable-offline-analytics\">Google Analytics 离线统计插件</a>，可惜我用的是 Sukka 大佬编写的<a href=\"https://github.com/SukkaW/cloudflare-workers-async-google-analytics\">非官方 Google Analytics 实现</a>，所以只能添加一个 <code>NetworkOnly</code> 来放弃离线统计。</p>\n<pre><code class=\"highlight javascript\">workbox.routing.registerRoute(\n    <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(<span class=\"string\">&#x27;^https://api\\\\.baoshuo\\\\.ren/cfga/(.*)&#x27;</span>),\n    <span class=\"keyword\">new</span> workbox.strategies.NetworkOnly(&#123;\n        plugins: [\n            <span class=\"keyword\">new</span> workbox.backgroundSync.BackgroundSyncPlugin(<span class=\"string\">&#x27;Optical_Collect&#x27;</span>, &#123;\n                maxRetentionTime: <span class=\"number\">12</span> * <span class=\"number\">60</span> <span class=\"comment\">// Retry for max of 12 Hours (specified in minutes)</span>\n            &#125;),\n        ]\n    &#125;)\n);</code></pre>\n<h3 id=\"图片\">图片</h3>\n<p>由于我开通了 <a href=\"http://SM.MS\">SM.MS</a> 的 LifeTime Premium VIP ，所以图片当然是要存到这里啦~</p>\n<p><a href=\"http://SM.MS\">SM.MS</a> 的图片域名有这几个：<code>i.loli.net</code>、<code>vip1.loli.net</code>、<code>vip2.loli.net</code>、<code>vip1.loli.io</code>、<code>vip2.loli.io</code>，只需要写一个正则匹配下就好了。</p>\n<p>由于图片链接对应的文件像 jsDelivr 一样也是几乎永久都不会改变的，所以使用 <code>CacheFirst</code> 来进行缓存。</p>\n<pre><code class=\"highlight javascript\">workbox.routing.registerRoute(\n    <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(<span class=\"string\">&#x27;^https://(?:i|vip[0-9])\\\\.loli\\\\.(?:io|net)&#x27;</span>),\n    <span class=\"keyword\">new</span> workbox.strategies.CacheFirst(&#123;\n        cacheName: <span class=\"string\">&#x27;img-cache&#x27;</span> + cacheSuffixVersion,\n        plugins: [\n            <span class=\"comment\">// 使用 expiration 插件实现缓存条目数目和时间控制</span>\n            <span class=\"keyword\">new</span> workbox.expiration.ExpirationPlugin(&#123;\n                maxEntries,                          <span class=\"comment\">// 最大保存项目</span>\n                maxAgeSeconds: <span class=\"number\">30</span> * <span class=\"number\">24</span> * <span class=\"number\">60</span> * <span class=\"number\">60</span>,    <span class=\"comment\">// 缓存 30 天</span>\n            &#125;),\n            <span class=\"comment\">// 使用 cacheableResponse 插件缓存状态码为 0 的请求</span>\n            <span class=\"keyword\">new</span> workbox.cacheableResponse.CacheableResponsePlugin(&#123;\n                statuses: [<span class=\"number\">0</span>, <span class=\"number\">200</span>],\n            &#125;),\n        ]\n    &#125;)\n);</code></pre>\n<h3 id=\"友情链接\">友情链接</h3>\n<p>这些文件只是偶尔更新，使用 <code>StaleWhileRevalidate</code> ，可以兼顾速度与版本更新。</p>\n<pre><code class=\"highlight javascript\">workbox.routing.registerRoute(\n    <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(<span class=\"string\">&#x27;^https://friends\\\\.baoshuo\\\\.ren(.*)(png|jpg|jpeg|svg|gif)&#x27;</span>),\n    <span class=\"keyword\">new</span> workbox.strategies.StaleWhileRevalidate(&#123;\n        cacheName: <span class=\"string\">&#x27;img-cache&#x27;</span> + cacheSuffixVersion,\n        fetchOptions: &#123;\n            mode: <span class=\"string\">&#x27;cors&#x27;</span>,\n            credentials: <span class=\"string\">&#x27;omit&#x27;</span>\n        &#125;\n    &#125;)\n);\nworkbox.routing.registerRoute(\n    <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(<span class=\"string\">&#x27;https://friends\\\\.baoshuo\\\\.ren/links.json&#x27;</span>),\n    <span class=\"keyword\">new</span> workbox.strategies.StaleWhileRevalidate()\n);</code></pre>\n<h3 id=\"Disqus-评论\">Disqus 评论</h3>\n<p>DisqusJS 判断访客的 Disqus 可用性是通过检查 <code>shortname.disqus.com/favicon.ico</code> 和 <code>disqus.com/favicon.ico</code> ，显然是不能被缓存的。<br>\nAPI 可以在无网络时使用 <code>NetworkFirst</code> 来达到无网络时也能查看评论的效果。<br>\n另外 Disqus 本身也没有缓存的必要，所以对 <code>*.disqus.com</code> 使用 <code>NetworkOnly</code> 即可。<br>\n但是 <code>*.disquscdn.com</code> 下的头像、JS、CSS 是可以缓存一段时间的，所以使用 <code>CacheFirst</code> 缓存 10 天。</p>\n<pre><code class=\"highlight javascript\"><span class=\"comment\">// API</span>\nworkbox.routing.registerRoute(\n    <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(<span class=\"string\">&#x27;^https://api\\\\.baoshuo\\\\.ren/disqus/(.*)&#x27;</span>),\n    <span class=\"keyword\">new</span> workbox.strategies.NetworkFirst(&#123;\n        cacheName: <span class=\"string\">&#x27;dsqjs-api&#x27;</span> + cacheSuffixVersion,\n        fetchOptions: &#123;\n            mode: <span class=\"string\">&#x27;cors&#x27;</span>,\n            credentials: <span class=\"string\">&#x27;omit&#x27;</span>\n        &#125;,\n        networkTimeoutSeconds: <span class=\"number\">3</span>\n    &#125;)\n);\n<span class=\"comment\">// Disqus</span>\nworkbox.routing.registerRoute(\n    <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(<span class=\"string\">&#x27;^https://(.*)disqus\\\\.com&#x27;</span>),\n    <span class=\"keyword\">new</span> workbox.strategies.NetworkOnly()\n);\nworkbox.routing.registerRoute(\n    <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(<span class=\"string\">&#x27;^https://(.*)disquscdn\\\\.com(.*)&#x27;</span>),\n    <span class=\"keyword\">new</span> workbox.strategies.CacheFirst(&#123;\n        cacheName: <span class=\"string\">&#x27;disqus-cdn-cache&#x27;</span> + cacheSuffixVersion,\n        plugins: [\n            <span class=\"keyword\">new</span> workbox.expiration.ExpirationPlugin(&#123;\n                maxAgeSeconds: <span class=\"number\">10</span> * <span class=\"number\">24</span> * <span class=\"number\">60</span> * <span class=\"number\">60</span>,\n            &#125;),\n            <span class=\"keyword\">new</span> workbox.cacheableResponse.CacheableResponsePlugin(&#123;\n                statuses: [<span class=\"number\">0</span>, <span class=\"number\">200</span>],\n            &#125;),\n        ]\n    &#125;)\n);</code></pre>\n<h3 id=\"后缀匹配\">后缀匹配</h3>\n<p>针对其余没有被域名匹配到的静态文件，通过文件后缀进行匹配并使用 <code>StaleWhileRevalidate</code> ，可以兼顾速度与版本更新。</p>\n<pre><code class=\"highlight javascript\">workbox.routing.registerRoute(\n    <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(<span class=\"string\">&#x27;.*\\.(?:png|jpg|jpeg|svg|gif|webp)&#x27;</span>),\n    <span class=\"keyword\">new</span> workbox.strategies.StaleWhileRevalidate()\n);\nworkbox.routing.registerRoute(\n    <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(<span class=\"string\">&#x27;.*\\.(css|js)&#x27;</span>),\n    <span class=\"keyword\">new</span> workbox.strategies.StaleWhileRevalidate()\n);</code></pre>\n<h3 id=\"默认行为\">默认行为</h3>\n<p>使用 Workbox 的 defaultHandler 匹配剩下的请求（包括页面自身），一律使用 <code>NetworkFirst</code> ，借助 Workbox 的 <code>runtimeCache</code> 起到加速和离线效果。</p>\n<pre><code class=\"highlight javascript\">workbox.routing.setDefaultHandler(\n    <span class=\"keyword\">new</span> workbox.strategies.NetworkFirst(&#123;\n        networkTimeoutSeconds: <span class=\"number\">3</span>\n    &#125;)\n);</code></pre>\n<h2 id=\"参考资料\">参考资料</h2>\n<p><em>文章头图来自：<a href=\"https://developers.google.com/web/tools/workbox\">https://developers.google.com/web/tools/workbox</a></em></p>\n<p><em><a href=\"#Workbox-%E7%AD%96%E7%95%A5\">Workbox 策略</a> 一节中的配图来自：<a href=\"https://web.dev/offline-cookbook/\">https://web.dev/offline-cookbook/</a></em></p>\n<ul>\n<li><a href=\"https://developers.google.com/web/tools/workbox/\">Workbox - Google Developers</a></li>\n<li><a href=\"https://blog.skk.moe/post/hello-workbox/\">Workbox, not sw-toolbox &amp; sw-precache - Sukka’s Blog</a></li>\n<li><a href=\"https://github.com/GoogleChrome/workbox\">GoogleChrome/workbox - GitHub</a></li>\n<li><a href=\"https://web.dev/offline-cookbook/#serving-suggestions\">The Offline Cookbook - web.dev</a></li>\n</ul>\n",
            "tags": [
                "Web",
                "ServiceWorker",
                "JavaScript"
            ]
        }
    ]
}