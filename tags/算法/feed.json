{
    "version": "https://jsonfeed.org/version/1",
    "title": "宝硕博客 • All posts by \"算法\" tag",
    "description": "宝硕博客 —— Baoshuo (@renbaoshuo) 随便写东西的地方，以技术向博文为主，生活向博文为辅。",
    "home_page_url": "https://blog.baoshuo.ren",
    "items": [
        {
            "id": "https://blog.baoshuo.ren/post/minimum-spanning-tree/",
            "url": "https://blog.baoshuo.ren/post/minimum-spanning-tree/",
            "title": "最小生成树学习笔记",
            "date_published": "2021-08-27T08:57:23.000Z",
            "content_html": "<p>在 OI 中常用的最小生成树算法有 <a href=\"#%E6%9C%B4%E7%B4%A0%E7%89%88-prim-%E7%AE%97%E6%B3%95\">朴素版 Prim 算法</a> 和 <a href=\"#krustal-%E7%AE%97%E6%B3%95\">Kruskal 算法</a> 。</p>\n<span id=\"more\"></span>\n<h2 id=\"朴素版-prim-算法\"><a class=\"anchor\" href=\"#朴素版-prim-算法\"></a>朴素版 Prim 算法</h2>\n<p>Prim 算法是一种常见且好写的最小生成树算法。</p>\n<p>朴素版 Prim 算法的基本思想是从一个结点开始不断加点，其时间复杂度约为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> ，适用于稠密图。</p>\n<h3 id=\"思路\"><a class=\"anchor\" href=\"#思路\"></a>思路</h3>\n<img src=\"https://vip2.loli.io/2021/08/10/OtvancqGr5MXuSe.gif\" width=\"400\" style=\"background: #ffffff33;\" alt=\"Prim 算法运行演示\" data-action=\"zoom\"><span class=\"image-description\">Prim 算法运行演示</span>\n<p>朴素版的 Prim 算法思想与我在 <a href=\"/post/graph-shortest-path/\" title=\"最短路学习笔记\">最短路学习笔记</a> 一文中提到的朴素版 Dijkstra 算法很相似。</p>\n<p>大体步骤如下：</p>\n<ol>\n<li>初始化一个 <code>dist</code> 数组，使所有距离均为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∞</mi></mrow><annotation encoding=\"application/x-tex\">\\infty</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord\">∞</span></span></span></span> 。<br>设集合 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span> 表示已经在连通块内的所有点。</li>\n<li>进行 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 次迭代：\n<ol>\n<li>找到集合外 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span> 中的距离最近的点，将其赋值给 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>t</mi></mrow><annotation encoding=\"application/x-tex\">t</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.61508em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">t</span></span></span></span> 。</li>\n<li>用 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>t</mi></mrow><annotation encoding=\"application/x-tex\">t</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.61508em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">t</span></span></span></span> 更新其他点到 <strong>集合 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"bold\">S</mi></mrow><annotation encoding=\"application/x-tex\">\\bold{S}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68611em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbf\">S</span></span></span></span></span></strong> 的距离。</li>\n<li>将 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>t</mi></mrow><annotation encoding=\"application/x-tex\">t</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.61508em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">t</span></span></span></span> 添加到集合 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span> 中。</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"代码\"><a class=\"anchor\" href=\"#代码\"></a>代码</h3>\n<p>题目： <a href=\"https://www.luogu.com.cn/problem/P3366\">P3366 【模板】最小生成树</a></p>\n<pre><code class=\"highlight cpp\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span>\n\n<span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;\n\n<span class=\"keyword\">int</span> n, m, u, v, w, g[<span class=\"number\">5005</span>][<span class=\"number\">5005</span>], dist[<span class=\"number\">5005</span>];\n<span class=\"keyword\">bool</span> vis[<span class=\"number\">5005</span>];\n\n<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">prim</span><span class=\"params\">()</span> </span>&#123;\n    <span class=\"built_in\">memset</span>(dist, <span class=\"number\">0x3f</span>, <span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(dist));\n    <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;\n    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;\n        <span class=\"keyword\">int</span> t = <span class=\"number\">-1</span>;\n        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt;= n; j++) &#123;\n            <span class=\"keyword\">if</span> (!vis[j] &amp;&amp; (t == <span class=\"number\">-1</span> || dist[j] &lt; dist[t])) &#123;\n                t = j;\n            &#125;\n        &#125;\n        <span class=\"keyword\">if</span> (i &amp;&amp; dist[t] == <span class=\"number\">0x3f3f3f3f</span>) <span class=\"keyword\">return</span> <span class=\"number\">0x3f3f3f3f</span>;\n        <span class=\"keyword\">if</span> (i) res += dist[t];\n        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt;= n; j++) &#123;\n            dist[j] = <span class=\"built_in\">min</span>(dist[j], g[t][j]);\n        &#125;\n        vis[t] = <span class=\"literal\">true</span>;\n    &#125;\n    <span class=\"keyword\">return</span> res;\n&#125;\n\n<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;\n    cin &gt;&gt; n &gt;&gt; m;\n    <span class=\"built_in\">memset</span>(g, <span class=\"number\">0x3f</span>, <span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(g));\n    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++) &#123;\n        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;\n        g[u][v] = g[v][u] = <span class=\"built_in\">min</span>(g[u][v], w);\n    &#125;\n    <span class=\"keyword\">int</span> ans = <span class=\"built_in\">prim</span>();\n    <span class=\"keyword\">if</span> (ans == <span class=\"number\">0x3f3f3f3f</span>) &#123;\n        cout &lt;&lt; <span class=\"string\">&quot;orz&quot;</span> &lt;&lt; endl;\n    &#125; <span class=\"keyword\">else</span> &#123;\n        cout &lt;&lt; ans &lt;&lt; endl;\n    &#125;\n    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;\n&#125;</code></pre>\n<h2 id=\"krustal-算法\"><a class=\"anchor\" href=\"#krustal-算法\"></a>Krustal 算法</h2>\n<p>时间复杂度约为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>m</mi><mi>log</mi><mo>⁡</mo><mi>m</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(m \\log m)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mclose\">)</span></span></span></span> ，适用于稀疏图。</p>\n<h3 id=\"思路-t2\"><a class=\"anchor\" href=\"#思路-t2\"></a>思路</h3>\n<img src=\"https://vip1.loli.io/2021/08/10/8YV6BviLTrGkIZD.gif\" width=\"400\" style=\"background: #ffffff33;\" alt=\"Krustal 算法运行演示\" data-action=\"zoom\"><span class=\"image-description\">Krustal 算法运行演示</span>\n<ol>\n<li>先将所有边按照权重从小到大排序。</li>\n<li>枚举每条边 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>a</mi><mo separator=\"true\">,</mo><mi>b</mi><mo separator=\"true\">,</mo><mi>c</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(a, b, c)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">c</span><span class=\"mclose\">)</span></span></span></span>，如果 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mo separator=\"true\">,</mo><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">a, b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span> 不连通，将这条边加入集合 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span> 。</li>\n</ol>\n<p>注：可以使用并查集维护联通块。</p>\n<h3 id=\"代码-t2\"><a class=\"anchor\" href=\"#代码-t2\"></a>代码</h3>\n<p>题目： <a href=\"https://www.luogu.com.cn/problem/P3366\">P3366 【模板】最小生成树</a></p>\n<pre><code class=\"highlight cpp\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span>\n\n<span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;\n\n<span class=\"keyword\">int</span> n, m, fa[<span class=\"number\">5005</span>], res, cnt;\n<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span> &#123;</span>\n    <span class=\"keyword\">int</span> u, v, w;\n\n    <span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span>&lt;(<span class=\"keyword\">const</span> node x) <span class=\"keyword\">const</span> &#123;\n        <span class=\"keyword\">return</span> w &lt; x.w;\n    &#125;\n&#125; g[<span class=\"number\">200005</span>];\n\n<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;\n    <span class=\"keyword\">return</span> fa[x] = fa[x] != x ? <span class=\"built_in\">find</span>(fa[x]) : fa[x];\n&#125;\n\n<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;\n    cin &gt;&gt; n &gt;&gt; m;\n    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++) &#123;\n        cin &gt;&gt; g[i].u &gt;&gt; g[i].v &gt;&gt; g[i].w;\n    &#125;\n    <span class=\"built_in\">sort</span>(g, g + m);\n    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;\n        fa[i] = i;\n    &#125;\n    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++) &#123;\n        g[i].u = <span class=\"built_in\">find</span>(g[i].u);\n        g[i].v = <span class=\"built_in\">find</span>(g[i].v);\n        <span class=\"keyword\">if</span> (g[i].u != g[i].v) &#123;\n            fa[g[i].u] = g[i].v;\n            res += g[i].w;\n            cnt++;\n        &#125;\n    &#125;\n    <span class=\"keyword\">if</span> (cnt &lt; n - <span class=\"number\">1</span>) &#123;\n        cout &lt;&lt; <span class=\"string\">&quot;orz&quot;</span> &lt;&lt; endl;\n    &#125; <span class=\"keyword\">else</span> &#123;\n        cout &lt;&lt; res &lt;&lt; endl;\n    &#125;\n    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;\n&#125;</code></pre>\n<h2 id=\"参考资料\"><a class=\"anchor\" href=\"#参考资料\"></a>参考资料</h2>\n<ol>\n<li><a href=\"https://oi-wiki.org/graph/mst/\">最小生成树 - OI Wiki</a></li>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91\">最小生成树 - 维基百科</a></li>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E6%99%AE%E6%9E%97%E5%A7%86%E7%AE%97%E6%B3%95\">Prim 算法 - 维基百科</a></li>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E5%85%8B%E9%B2%81%E6%96%AF%E5%85%8B%E5%B0%94%E6%BC%94%E7%AE%97%E6%B3%95\">Kruskal 算法 - 维基百科</a></li>\n</ol>\n<hr>\n<p>本文中 Prim 算法、 Kruskal 算法的演示图片原稿来自维基共享资源，原作者为 <a href=\"https://commons.wikimedia.org/wiki/User:Alexander_Drichel\">Alexander Drichel</a> ，经本人整合后以 <a href=\"https://creativecommons.org/licenses/by-sa/3.0/legalcode.txt\">CC BY-SA 3.0</a> 协议发布，初版可见 <a href=\"https://github.com/OI-wiki/OI-wiki/commit/caf2ba8bdb69c60adc897b816859c6414f04999a\"><code>caf2ba8</code>@OI-wiki/OI-wiki</a>，本文其余内容的版权协议见正文下方「版权声明」处。</p>\n",
            "tags": [
                "算法",
                "图论",
                "笔记"
            ]
        },
        {
            "id": "https://blog.baoshuo.ren/post/graph-shortest-path/",
            "url": "https://blog.baoshuo.ren/post/graph-shortest-path/",
            "title": "最短路学习笔记",
            "date_published": "2021-08-12T02:50:06.000Z",
            "content_html": "<p>最短路径问题是图论研究中的一个经典算法问题，旨在寻找图（由节点和路径组成的）中两节点之间的最短路径。</p>\n<span id=\"more\"></span>\n<p>由于竞赛中不考查文中所述算法的证明，故本文不探讨与证明相关的内容，如有需要请自行查阅维基百科。</p>\n<h2 id=\"性质\"><a class=\"anchor\" href=\"#性质\"></a>性质</h2>\n<ol>\n<li>对于边权为正的图，任意两个节点间的最短路不会重复经过某一个点或某一条边。</li>\n<li>对于边权为正的图，任意两个节点间的最短路中的任意一条的节点数不会超过 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> ，边数不会超过 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">n - 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 。</li>\n</ol>\n<h2 id=\"确定起点的最短路径问题\"><a class=\"anchor\" href=\"#确定起点的最短路径问题\"></a>确定起点的最短路径问题</h2>\n<p>这种问题也叫单源最短路问题，即已知起始节点，求最短路径的问题。在边权非负时适合使用 Dijkstra 算法，若边权为负时则适合使用 Bellman-ford 算法或者 SPFA 算法。</p>\n<h3 id=\"dijkstra-算法\"><a class=\"anchor\" href=\"#dijkstra-算法\"></a>Dijkstra 算法</h3>\n<p>该算法的时间复杂度为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> ，使用<a href=\"#%E5%A0%86%E4%BC%98%E5%8C%96%E7%9A%84-Dijkstra-%E7%AE%97%E6%B3%95\">堆优化</a>后可达 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>m</mi><mi>log</mi><mo>⁡</mo><mi>m</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(m \\log m)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mclose\">)</span></span></span></span> 。</p>\n<h4 id=\"演示\"><a class=\"anchor\" href=\"#演示\"></a>演示</h4>\n<p><img src=\"https://vip2.loli.io/2021/07/19/Ppk3vdLbMyqKoEl.gif\" alt=\"Dijkstra 算法运行演示\" loading=\"lazy\" data-action=\"zoom\"><span class=\"image-description\">Dijkstra 算法运行演示</span></p>\n<p>Dijkstra 算法每次取出未访问节点中距离最小的节点，并用该节点更新其他节点的距离。（在演示过程中访问过的节点会被标为红色）</p>\n<h4 id=\"实现\"><a class=\"anchor\" href=\"#实现\"></a>实现</h4>\n<ol>\n<li>定义一个名为 <code>dist</code> 的数组存储从起点到各点的距离，并将起点的值初始化为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span> 、其余点的距离初始化为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∞</mi></mrow><annotation encoding=\"application/x-tex\">\\infty</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord\">∞</span></span></span></span> 。<br>定义一个名为 <code>g</code> 的二维数组存图，将各点自己到自己的距离值初始化为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span> ，其余距离值初始化为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∞</mi></mrow><annotation encoding=\"application/x-tex\">\\infty</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord\">∞</span></span></span></span> 。<br>设集合 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span> 存储当前已确定最短路的点。</li>\n<li>遍历 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">n - 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 次，每次寻找一个不在 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span> 中的且距离起点最近的点，记为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>t</mi></mrow><annotation encoding=\"application/x-tex\">t</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.61508em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">t</span></span></span></span> ，并将 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>t</mi></mrow><annotation encoding=\"application/x-tex\">t</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.61508em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">t</span></span></span></span> 加入集合 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span> 。当从起点到某个点的距离比从起点经过 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>t</mi></mrow><annotation encoding=\"application/x-tex\">t</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.61508em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">t</span></span></span></span> 再到这个点的距离大时就更新从起点到这个点的距离，即 <code>dist[j] = min(dist[j], dist[t] + g[t][j])</code> 。</li>\n<li>最后 <code>dist</code> 数组里即为从起点到各点的最短距离。</li>\n</ol>\n<h4 id=\"代码\"><a class=\"anchor\" href=\"#代码\"></a>代码</h4>\n<p>题目链接：<a href=\"https://www.acwing.com/problem/content/description/851/\">849. Dijkstra 求最短路 I - AcWing</a></p>\n<pre><code class=\"highlight cpp\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span>\n\n<span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;\n\n<span class=\"keyword\">int</span> n, m, x, y, z, g[<span class=\"number\">505</span>][<span class=\"number\">505</span>], dist[<span class=\"number\">505</span>];\n<span class=\"keyword\">bool</span> st[<span class=\"number\">505</span>];\n\n<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">diskstra</span><span class=\"params\">()</span> </span>&#123;\n    <span class=\"built_in\">memset</span>(dist, <span class=\"number\">0x3f</span>, <span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(dist));\n    dist[<span class=\"number\">1</span>] = <span class=\"number\">0</span>;\n    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; n; i++) &#123;\n        <span class=\"keyword\">int</span> t = <span class=\"number\">-1</span>;\n        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt;= n; j++) &#123;\n            <span class=\"keyword\">if</span> (!st[j] &amp;&amp; (t == <span class=\"number\">-1</span> || dist[t] &gt; dist[j])) &#123;\n                t = j;\n            &#125;\n        &#125;\n        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt;= n; j++) &#123;\n            dist[j] = <span class=\"built_in\">min</span>(dist[j], dist[t] + g[t][j]);\n        &#125;\n        st[t] = <span class=\"literal\">true</span>;\n    &#125;\n    <span class=\"keyword\">return</span> dist[n] == <span class=\"number\">0x3f3f3f3f</span> ? <span class=\"number\">-1</span> : dist[n];\n&#125;\n\n<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;\n    cin &gt;&gt; n &gt;&gt; m;\n    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;\n        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt;= n; j++) &#123;\n            g[i][j] = i == j ? <span class=\"number\">0</span> : <span class=\"number\">0x3f3f3f3f</span>;\n        &#125;\n    &#125;\n    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= m; i++) &#123;\n        cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;\n        g[x][y] = <span class=\"built_in\">min</span>(g[x][y], z);\n    &#125;\n    cout &lt;&lt; <span class=\"built_in\">diskstra</span>() &lt;&lt; endl;\n    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;\n&#125;</code></pre>\n<h3 id=\"堆优化的-dijkstra-算法\"><a class=\"anchor\" href=\"#堆优化的-dijkstra-算法\"></a>堆优化的 Dijkstra 算法</h3>\n<p>使用堆优化的 Dijkstra 算法的时间复杂度为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>m</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(m \\log n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></p>\n<h4 id=\"实现-t2\"><a class=\"anchor\" href=\"#实现-t2\"></a>实现</h4>\n<p>使用堆代替找距离最近的点的操作即可。</p>\n<p>由于 C++ STL 中的优先队列不支持删除元素的操作，所以队列中会有重复元素导致复杂度变为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>m</mi><mi>log</mi><mo>⁡</mo><mi>m</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(m \\log m)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mclose\">)</span></span></span></span> ，但比手写堆要容易许多。</p>\n<h4 id=\"代码-t2\"><a class=\"anchor\" href=\"#代码-t2\"></a>代码</h4>\n<p>题目链接：<a href=\"https://www.acwing.com/problem/content/description/852/\">850. Dijkstra 求最短路 II</a></p>\n<pre><code class=\"highlight cpp\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span>\n\n<span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;\n\n<span class=\"keyword\">int</span> n, m, u, v, w, dist[<span class=\"number\">200005</span>];\nvector&lt;pair&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt;&gt; g[<span class=\"number\">200005</span>];\n<span class=\"keyword\">bool</span> st[<span class=\"number\">200005</span>];\n\n<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dijkstra</span><span class=\"params\">()</span> </span>&#123;\n    <span class=\"built_in\">memset</span>(dist, <span class=\"number\">0x3f</span>, <span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(dist));\n    dist[<span class=\"number\">1</span>] = <span class=\"number\">0</span>;\n    priority_queue&lt;pair&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt;, vector&lt;pair&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt;&gt;, greater&lt;pair&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt;&gt;&gt; q;\n    q.<span class=\"built_in\">push</span>(<span class=\"built_in\">make_pair</span>(<span class=\"number\">0</span>, <span class=\"number\">1</span>));\n    <span class=\"keyword\">while</span> (!q.<span class=\"built_in\">empty</span>()) &#123;\n        <span class=\"keyword\">auto</span> t = q.<span class=\"built_in\">top</span>();\n        q.<span class=\"built_in\">pop</span>();\n        <span class=\"keyword\">if</span> (st[t.second]) <span class=\"keyword\">continue</span>;\n        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> i : g[t.second]) &#123;\n            <span class=\"keyword\">if</span> (dist[i.first] &gt; t.first + i.second) &#123;\n                dist[i.first] = t.first + i.second;\n                q.<span class=\"built_in\">push</span>(<span class=\"built_in\">make_pair</span>(dist[i.first], i.first));\n            &#125;\n        &#125;\n        st[tw] = <span class=\"literal\">true</span>;\n    &#125;\n&#125;\n\n<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;\n    cin &gt;&gt; n &gt;&gt; m;\n    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= m; i++) &#123;\n        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;\n        g[u].<span class=\"built_in\">push_back</span>(<span class=\"built_in\">make_pair</span>(v, w));\n    &#125;\n    <span class=\"built_in\">dijkstra</span>();\n    cout &lt;&lt; (dist[n] == <span class=\"number\">0x3f3f3f3f</span> ? <span class=\"number\">-1</span> : dist[n]) &lt;&lt; endl;\n    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;\n&#125;</code></pre>\n<h3 id=\"bellman-ford-算法\"><a class=\"anchor\" href=\"#bellman-ford-算法\"></a>Bellman-Ford 算法</h3>\n<p>该算法的时间复杂度为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mi>m</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(nm)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">m</span><span class=\"mclose\">)</span></span></span></span> （对于存在最短路的图）。</p>\n<h4 id=\"实现-t3\"><a class=\"anchor\" href=\"#实现-t3\"></a>实现</h4>\n<ol>\n<li>定义一个名为 <code>dist</code> 的数组存储从起点到各点的距离，并将起点的值初始化为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span> 、其余点的距离初始化为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∞</mi></mrow><annotation encoding=\"application/x-tex\">\\infty</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord\">∞</span></span></span></span> 。</li>\n<li>遍历 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 次，并进行以下操作：\n<ol>\n<li>遍历所有边 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>u</mi><mo separator=\"true\">,</mo><mi>v</mi><mo separator=\"true\">,</mo><mi>w</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(u, v, w)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">u</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mclose\">)</span></span></span></span> ：若已有的从起点到 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi></mrow><annotation encoding=\"application/x-tex\">v</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span></span></span></span> 的路径长度大于从起点经过 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>u</mi><mo>→</mo><mi>v</mi></mrow><annotation encoding=\"application/x-tex\">u \\to v</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">u</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span></span></span></span> 这条边的路径长度，则更新最短路径长度。</li>\n</ol>\n</li>\n<li><code>dist</code> 数组即为所求。</li>\n</ol>\n<h4 id=\"判断负环\"><a class=\"anchor\" href=\"#判断负环\"></a>判断负环</h4>\n<p>在第 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 次遍历后如果仍能更新最短路径长度则可以判断存在负环。</p>\n<h4 id=\"代码-t3\"><a class=\"anchor\" href=\"#代码-t3\"></a>代码</h4>\n<pre><code class=\"highlight cpp\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span>\n\n<span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;\n\n<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span> &#123;</span>\n    <span class=\"keyword\">int</span> u, v, w;\n&#125; g[<span class=\"number\">10005</span>];\n\n<span class=\"keyword\">int</span> n, m, k, dist[<span class=\"number\">505</span>];\n\n<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">bellman_ford</span><span class=\"params\">()</span> </span>&#123;\n    <span class=\"built_in\">memset</span>(dist, <span class=\"number\">0x3f</span>, <span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(dist));\n    dist[<span class=\"number\">1</span>] = <span class=\"number\">0</span>;\n    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= k; i++) &#123;\n        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt;= m; j++) &#123;\n            dist[g[j].v] = <span class=\"built_in\">min</span>(dist[g[j].v], dist[g[j].u] + g[j].w);\n        &#125;\n    &#125;\n&#125;\n\n<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;\n    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= m; i++) &#123;\n        cin &gt;&gt; g[i].u &gt;&gt; g[i].v &gt;&gt; g[i].w;\n    &#125;\n    <span class=\"built_in\">bellman_ford</span>();\n    <span class=\"keyword\">if</span> (dist[n] &gt; <span class=\"number\">0x1f1f1f1f</span>) &#123;\n        cout &lt;&lt; <span class=\"string\">&quot;impossible&quot;</span> &lt;&lt; endl;\n    &#125; <span class=\"keyword\">else</span> &#123;\n        cout &lt;&lt; dist[n] &lt;&lt; endl;\n    &#125;\n    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;\n&#125;</code></pre>\n<h3 id=\"spfa-算法\"><a class=\"anchor\" href=\"#spfa-算法\"></a>SPFA 算法</h3>\n<p>SPFA 算法在国际上通称为「队列优化的 Bellman-Ford 算法」，时间复杂度为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mi>m</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(nm)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">m</span><span class=\"mclose\">)</span></span></span></span> 。</p>\n<h4 id=\"实现-t4\"><a class=\"anchor\" href=\"#实现-t4\"></a>实现</h4>\n<ol>\n<li>先初始化一个队列，并将起点入队。</li>\n<li>一直循环直到队列为空：\n<ol>\n<li>取出队头，设其为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>t</mi></mrow><annotation encoding=\"application/x-tex\">t</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.61508em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">t</span></span></span></span> 并出队。</li>\n<li>如果 <code>dist[t]</code> 可以变小，则更新 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>t</mi></mrow><annotation encoding=\"application/x-tex\">t</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.61508em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">t</span></span></span></span> 的所有出边 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>t</mi><mover><mo stretchy=\"true\">→</mo><mpadded width=\"+0.6em\" lspace=\"0.3em\"><mi>w</mi></mpadded></mover><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">t \\xrightarrow{w} b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.934392em;vertical-align:-0.01100000000000001em;\"></span><span class=\"mord mathnormal\">t</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel x-arrow\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.923392em;\"><span style=\"top:-3.322em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight x-arrow-pad\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02691em;\">w</span></span></span></span><span class=\"svg-align\" style=\"top:-2.689em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"hide-tail\" style=\"height:0.522em;min-width:1.469em;\"><svg width='400em' height='0.522em' viewBox='0 0 400000 522' preserveAspectRatio='xMaxYMin slice'><path d='M0 241v40h399891c-47.3 35.3-84 78-110 128\n-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20\n 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7\n 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85\n-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5\n-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67\n 151.7 139 205zm0 0v40h399900v-40z'/></svg></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.01100000000000001em;\"><span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span> ，如果更新成功将 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span> 加入队列。</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"spfa-判负环\"><a class=\"anchor\" href=\"#spfa-判负环\"></a>SPFA 判负环</h4>\n<p>在每次更新 <code>dist[x]</code> 的同时记录当前所走过的边数 <code>cnt[x] = cnt[t] + 1</code> ，若 <code>cnt[n]</code> 大于等于 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 则可以证明存在图中负环。</p>\n<p>由于从 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 号点开始走不能保证走到所有的负环，因此需要将节点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn><mo>∼</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">1 \\sim n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∼</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 都入队进行查找。</p>\n<h4 id=\"卡-spfa\"><a class=\"anchor\" href=\"#卡-spfa\"></a>卡 SPFA</h4>\n<ol>\n<li>生成一棵以起点为根的树，树高尽量高（比如 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 为起点时，可以令每个点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> 的父亲在 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>max</mi><mo>⁡</mo><mo stretchy=\"false\">(</mo><mi>i</mi><mo>−</mo><mn>5</mn><mo separator=\"true\">,</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\max(i - 5, 1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\">max</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">5</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span> 到 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">i - 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.74285em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 随机），边权随机，作为最短路径树，同时直接递推求出每个点的带权深度 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>d</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">d_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.84444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></li>\n<li>对于剩下的边，端点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>a</mi><mo separator=\"true\">,</mo><mi>b</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(a, b)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mclose\">)</span></span></span></span> 随机，边权在 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∣</mi><msub><mi>d</mi><mi>b</mi></msub><mo>−</mo><msub><mi>d</mi><mi>a</mi></msub><mi mathvariant=\"normal\">∣</mi></mrow><annotation encoding=\"application/x-tex\">|d_b - d_a|</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.33610799999999996em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">b</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">a</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord\">∣</span></span></span></span> 到 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∣</mi><msub><mi>d</mi><mi>b</mi></msub><mo>−</mo><msub><mi>d</mi><mi>a</mi></msub><mi mathvariant=\"normal\">∣</mi><mo>+</mo><mn>5</mn></mrow><annotation encoding=\"application/x-tex\">|d_b - d_a| + 5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.33610799999999996em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">b</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">a</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord\">∣</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">5</span></span></span></span> 随机（如果是有向图则去掉绝对值符号， <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>5</mn></mrow><annotation encoding=\"application/x-tex\">5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">5</span></span></span></span> 可以换成其他较小的正数）</li>\n</ol>\n<p>这样生成的图中，次短路的条数非常的多，而 SPFA 一旦错误地进入了次短路的分支，就会使得一整棵子树被赋错误的距离，从而在后期不得不重新更新。而由于边权接近，剪枝的效果会受到很大影响。</p>\n<h4 id=\"代码-t4\"><a class=\"anchor\" href=\"#代码-t4\"></a>代码</h4>\n<p><strong>SPFA 求最短路</strong></p>\n<p>题目：<a href=\"https://www.acwing.com/problem/content/853/\">851. spfa求最短路 - AcWing</a></p>\n<pre><code class=\"highlight cpp\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span>\n\n<span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;\n\n<span class=\"keyword\">int</span> n, m, u, v, w, dist[<span class=\"number\">100005</span>];\nvector&lt;pair&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt;&gt; g[<span class=\"number\">100005</span>];\n\n<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">spfa</span><span class=\"params\">()</span> </span>&#123;\n    <span class=\"built_in\">memset</span>(dist, <span class=\"number\">0x3f</span>, <span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(dist));\n    dist[<span class=\"number\">1</span>] = <span class=\"number\">0</span>;\n    queue&lt;<span class=\"keyword\">int</span>&gt; q;\n    q.<span class=\"built_in\">push</span>(<span class=\"number\">1</span>);\n    <span class=\"keyword\">while</span> (!q.<span class=\"built_in\">empty</span>()) &#123;\n        <span class=\"keyword\">int</span> t = q.<span class=\"built_in\">front</span>();\n        q.<span class=\"built_in\">pop</span>();\n        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> i : g[t]) &#123;\n            <span class=\"keyword\">if</span> (dist[i.first] &gt; dist[t] + i.second) &#123;\n                dist[i.first] = dist[t] + i.second;\n                q.<span class=\"built_in\">push</span>(i.first);\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;\n    cin &gt;&gt; n &gt;&gt; m;\n    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++) &#123;\n        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;\n        g[u].<span class=\"built_in\">push_back</span>(<span class=\"built_in\">make_pair</span>(v, w));\n    &#125;\n    <span class=\"built_in\">spfa</span>();\n    <span class=\"keyword\">if</span> (dist[n] == <span class=\"number\">0x3f3f3f3f</span>) &#123;\n        cout &lt;&lt; <span class=\"string\">&quot;impossible&quot;</span> &lt;&lt; endl;\n    &#125; <span class=\"keyword\">else</span> &#123;\n        cout &lt;&lt; dist[n] &lt;&lt; endl;\n    &#125;\n    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;\n&#125;</code></pre>\n<p><strong>SPFA 判负环</strong></p>\n<p>题目：<a href=\"https://www.acwing.com/problem/content/854/\">852. spfa判断负环 - AcWing</a></p>\n<pre><code class=\"highlight cpp\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span>\n\n<span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;\n\n<span class=\"keyword\">int</span> n, m, u, v, w, dist[<span class=\"number\">100005</span>], cnt[<span class=\"number\">100005</span>];\nvector&lt;pair&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt;&gt; g[<span class=\"number\">100005</span>];\n\n<span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">spfa</span><span class=\"params\">()</span> </span>&#123;\n    <span class=\"built_in\">memset</span>(dist, <span class=\"number\">0x3f</span>, <span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(dist));\n    queue&lt;<span class=\"keyword\">int</span>&gt; q;\n    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;\n        q.<span class=\"built_in\">push</span>(i);\n    &#125;\n    <span class=\"keyword\">while</span> (!q.<span class=\"built_in\">empty</span>()) &#123;\n        <span class=\"keyword\">int</span> t = q.<span class=\"built_in\">front</span>();\n        q.<span class=\"built_in\">pop</span>();\n        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> i : g[t]) &#123;\n            <span class=\"keyword\">if</span> (dist[i.first] &gt; dist[t] + i.second) &#123;\n                dist[i.first] = dist[t] + i.second;\n                cnt[i.first] = cnt[t] + <span class=\"number\">1</span>;\n                <span class=\"keyword\">if</span> (cnt[i.first] &gt;= n) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;\n                q.<span class=\"built_in\">push</span>(i.first);\n            &#125;\n        &#125;\n    &#125;\n    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;\n&#125;\n\n<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;\n    cin &gt;&gt; n &gt;&gt; m;\n    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++) &#123;\n        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;\n        g[u].<span class=\"built_in\">push_back</span>(<span class=\"built_in\">make_pair</span>(v, w));\n    &#125;\n    cout &lt;&lt; (<span class=\"built_in\">spfa</span>() ? <span class=\"string\">&quot;Yes&quot;</span> : <span class=\"string\">&quot;No&quot;</span>) &lt;&lt; endl;\n    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;\n&#125;</code></pre>\n<h2 id=\"确定终点的最短路径问题\"><a class=\"anchor\" href=\"#确定终点的最短路径问题\"></a>确定终点的最短路径问题</h2>\n<p>与确定起点的问题相反，该问题是已知终结节点，求最短路径的问题。在无向图中该问题与确定起点的问题完全等同，在有向图中该问题等同于把所有路径方向反转的确定起点的问题。</p>\n<p>只需要反向存图然后再跑一遍单源最短路即可。</p>\n<h2 id=\"确定起点终点的最短路径问题\"><a class=\"anchor\" href=\"#确定起点终点的最短路径问题\"></a>确定起点终点的最短路径问题</h2>\n<p>即已知起点和终点，求两节点之间的最短路径。</p>\n<p>可以使用单源最短路算法并进行剪枝：在处理完到终点的最短路径后直接停止计算最短路。</p>\n<h2 id=\"全局最短路径问题\"><a class=\"anchor\" href=\"#全局最短路径问题\"></a>全局最短路径问题</h2>\n<p>也叫多源最短路问题，求图中所有的最短路径。适合使用 Floyd 算法，时间复杂度为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>3</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^3)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">3</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> 。</p>\n<h3 id=\"实现-t5\"><a class=\"anchor\" href=\"#实现-t5\"></a>实现</h3>\n<p>定义一个三维数组 <code>f[k][x][y]</code> ，表示只允许从 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">x</span></span></span></span> 点经过节点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn><mo>∼</mo><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">1 \\sim k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∼</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 点到 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>y</mi></mrow><annotation encoding=\"application/x-tex\">y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span></span></span></span> 点的最短距离，那么很容易得出从 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 点到 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 点的最短路径为 <code>f[n][1][n]</code> 。</p>\n<p>之后使用三重循环枚举即可。</p>\n<h3 id=\"代码-t5\"><a class=\"anchor\" href=\"#代码-t5\"></a>代码</h3>\n<pre><code class=\"highlight cpp\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span>\n\n<span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;\n\n<span class=\"keyword\">int</span> n, m, k, x, y, z, f[<span class=\"number\">205</span>][<span class=\"number\">205</span>];\n\n<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;\n    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;\n        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt;= n; j++) &#123;\n            f[i][j] = i == j ? <span class=\"number\">0</span> : <span class=\"number\">0x3f3f3f3f3f</span>;\n        &#125;\n    &#125;\n    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= m; i++) &#123;\n        cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;\n        f[x][y] = <span class=\"built_in\">min</span>(f[x][y], z);\n    &#125;\n    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = <span class=\"number\">1</span>; k &lt;= n; k++) &#123;\n        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;\n            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt;= n; j++) &#123;\n                f[i][j] = <span class=\"built_in\">min</span>(f[i][j], f[i][k] + f[k][j]);\n            &#125;\n        &#125;\n    &#125;\n    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= k; i++) &#123;\n        cin &gt;&gt; x &gt;&gt; y;\n        <span class=\"keyword\">if</span> (f[x][y] &gt; <span class=\"number\">0x1fffffff</span>) &#123;\n            cout &lt;&lt; <span class=\"string\">&quot;impossible&quot;</span> &lt;&lt; endl;\n        &#125; <span class=\"keyword\">else</span> &#123;\n            cout &lt;&lt; f[x][y] &lt;&lt; endl;\n        &#125;\n    &#125;\n    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;\n&#125;</code></pre>\n<h2 id=\"参考资料\"><a class=\"anchor\" href=\"#参考资料\"></a>参考资料</h2>\n<ol>\n<li><a href=\"https://oi-wiki.org/graph/shortest-path/\">最短路 - 图论 - OI Wiki</a></li>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98\">最短路问题 - 维基百科</a></li>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E6%88%B4%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95\">戴克斯特拉算法 (Dijkstra 算法) - 维基百科</a></li>\n<li><a href=\"https://zh.wikipedia.org/wiki/Floyd-Warshall%E7%AE%97%E6%B3%95\">Floyd-Warshall 算法 - 维基百科</a></li>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E8%B4%9D%E5%B0%94%E6%9B%BC-%E7%A6%8F%E7%89%B9%E7%AE%97%E6%B3%95\">Bellman-ford 算法 - 维基百科</a></li>\n<li><a href=\"https://www.zhihu.com/question/292283275/answer/484694411\">如何看待 SPFA 算法已死这种说法？ - immortalCO 的回答 - 知乎</a></li>\n</ol>\n<p><em>（文章头图来自《啊哈！算法》）</em></p>\n",
            "tags": [
                "算法",
                "图论",
                "笔记"
            ]
        }
    ]
}